<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Montagem â€” Filtro Wega Motor + Clips Snap-fit</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',system-ui,sans-serif;background:#1a1a2e;overflow:hidden}
#c{width:100vw;height:100vh;display:block}
#panel{position:absolute;top:10px;left:10px;background:rgba(255,255,255,.97);padding:14px;border-radius:10px;max-width:320px;box-shadow:0 8px 30px rgba(0,0,0,.4);max-height:calc(100vh - 20px);overflow-y:auto}
h1{font-size:.95rem;color:#2c3e50;margin-bottom:2px}
.sub{font-size:.6rem;color:#7f8c8d;margin-bottom:8px}
.step{background:#fff3e0;padding:10px;border-radius:8px;margin-bottom:8px;border-left:3px solid #ff9800}
.step h2{font-size:.78rem;color:#2c3e50;margin-bottom:3px}
.step p{font-size:.65rem;color:#555;line-height:1.35}
.nav{display:flex;gap:6px;margin-bottom:8px}
.nav button{flex:1;padding:7px;border:none;border-radius:6px;font-size:.72rem;font-weight:600;cursor:pointer;transition:.15s}
.bp{background:#ecf0f1;color:#2c3e50}.bp:hover{background:#d5dbdb}
.bn{background:#ff9800;color:#fff}.bn:hover{background:#f57c00}
.sec{background:#f8f9fa;border:1px solid #dee2e6;border-radius:6px;padding:8px;margin-bottom:8px}
.sec h3{font-size:.68rem;color:#495057;margin-bottom:4px}
.sec pre{font-size:.58rem;line-height:1.3;color:#333;font-family:'Cascadia Code','Consolas',monospace}
.specs{font-size:.6rem;color:#666;margin-bottom:6px}
.specs table{width:100%;border-collapse:collapse}
.specs td{padding:1px 4px}.specs .l{color:#888}.specs .v{font-weight:600;text-align:right}
.warn{background:#fff3cd;border:1px solid #ffc107;border-radius:4px;padding:5px;font-size:.58rem;color:#856404;margin-bottom:6px}
.legend{display:flex;gap:8px;flex-wrap:wrap}
.legend span{display:flex;align-items:center;gap:3px;font-size:.58rem}
.legend i{width:10px;height:10px;border-radius:2px;display:inline-block}
#info{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,.85);padding:5px 14px;border-radius:6px;font-size:.62rem;white-space:nowrap}
</style>
</head>
<body>
<div id="c"></div>
<div id="panel">
  <h1>ğŸ”§ Montagem â€” Wega Motor</h1>
  <div class="sub">DivisÃ³ria 244Ã—240mm Â· Furo 220Ã—164mm Â· Borda 246Ã—183Ã—4mm Â· 6 clips</div>
  <div class="step"><h2 id="sT"></h2><p id="sD"></p></div>
  <div class="nav">
    <button class="bp" onclick="prev()">â† Anterior</button>
    <button class="bn" onclick="next()">PrÃ³ximo â†’</button>
  </div>
  <div class="warn">âš ï¸ Clips com lip â€” engancham na borda do furo, SEM furar o MDF</div>
  <div class="sec">
    <h3>SeÃ§Ã£o transversal do clip</h3>
    <pre>
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ aba 11.5mm â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                         â”Œâ”€â” batente
       â”‚   frame 4mm             â”‚ â”‚
       â”‚   (Y=0..9.5)            â”‚ â”‚
       â”‚â•â•â• MDF 3mm â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚
       â””â”€lipâ”€â”˜    (furo)         â””â”€â”˜
         3mm
    </pre>
  </div>
  <div class="specs"><table>
    <tr><td class="l">Filtro:</td><td class="v">Wega Motor â€” corpo 220Ã—160Ã—45mm</td></tr>
    <tr><td class="l">Frame:</td><td class="v">246Ã—183Ã—4mm (repousa no MDF)</td></tr>
    <tr><td class="l">Furo MDF:</td><td class="v">220Ã—164mm (SEM slots)</td></tr>
    <tr><td class="l">Clips:</td><td class="v">6Ã— (larg 30mm, lip 3mm, aba 11.5mm)</td></tr>
  </table></div>
  <div class="legend">
    <span><i style="background:#CD853F"></i>MDF</span>
    <span><i style="background:#34495e"></i>Filtro</span>
    <span><i style="background:#e67e22"></i>Clip</span>
  </div>
</div>
<div id="info">ğŸ–±ï¸ Arrastar = Girar Â· Scroll = Zoom Â· â† â†’ = Passos</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ===== DADOS DO NC E SCAD ===== */
// Escala: 1 unidade = 100mm

// MDF 244Ã—240Ã—3mm
const W = 2.44, H = 2.40, T = 0.03;

// Furo 220Ã—164mm (X: 12-232, Y: 38-202)
const HOLE_X1 = 0.12, HOLE_X2 = 2.32;
const HOLE_Z1 = 0.38, HOLE_Z2 = 2.02;
const HOLE_W = HOLE_X2 - HOLE_X1;  // 2.20
const HOLE_H = HOLE_Z2 - HOLE_Z1;  // 1.64

// Filtro Wega Motor â€” corpo 220Ã—160Ã—41mm (mÃ­dia), frame 246Ã—183Ã—4mm (borda PU)
const FILT_W = 2.20, FILT_H = 1.60, FILT_T = 0.45;
const FRAME_W = 2.46, FRAME_H = 1.83; // frame/borda (poliuretano)
const BORDA_W = 0.10, BORDA_ESP = 0.04;

// Clip (CLIP_WEGA.scad)
const CLIP_LARG = 0.30;    // 30mm
const CLIP_PAREDE = 0.02;  // 2mm
const ABA_COMP = 0.115;     // 11.5mm (wega_borda_larg 9.5 + 2mm garra)
const ABA_ESP = 0.015;     // 1.5mm
const BATENTE_ALT = 0.025; // 2.5mm
const LIP_PROF = 0.03;    // 3mm
const LIP_ESP = 0.02;     // 2mm
const FOLGA = 0.005;       // 0.5mm folga_filtro

// PosiÃ§Ãµes dos 6 clips (NC: X=60,122,184 â€” sÃ³ lados Y, lados X tÃªm trilhos)
const CLIPS = [
  // Inferior (Y=40 â†’ Z=0.40)
  { x: 0.60, z: HOLE_Z1, rot: Math.PI },
  { x: 1.22, z: HOLE_Z1, rot: Math.PI },
  { x: 1.84, z: HOLE_Z1, rot: Math.PI },
  // Superior (Y=200 â†’ Z=2.00)
  { x: 0.60, z: HOLE_Z2, rot: 0 },
  { x: 1.22, z: HOLE_Z2, rot: 0 },
  { x: 1.84, z: HOLE_Z2, rot: 0 }
];

// Sem slots â€” clips com lip engancham na borda do furo
const SLOTS_H = [];
const SLOTS_V = [];

const STEPS = [
  { title: "Etapa 1/4 â€” DivisÃ³ria MDF",
    desc: "Placa MDF 244Ã—240Ã—3mm. Furo 220Ã—164mm centralizado para o corpo do filtro Wega Motor. SEM slots.",
    show: { mdf: true, slots: false, filter: false, clips: false } },
  { title: "Etapa 2/4 â€” Posicionar Filtro Wega",
    desc: "Coloque o filtro Wega Motor. Corpo 220Ã—160Ã—41mm (mÃ­dia) passa pelo furo. Borda 246Ã—183Ã—4mm (PU) repousa sobre o MDF.",
    show: { mdf: true, slots: false, filter: true, clips: false } },
  { title: "Etapa 3/4 â€” Encaixar os 6 Clips",
    desc: "6 clips nos lados Y. Lip engancha sob o MDF na borda do furo. Aba + batente abraÃ§am o frame.",
    show: { mdf: true, slots: false, filter: true, clips: true } },
  { title: "Etapa 4/4 â€” Montagem Completa",
    desc: "âœ… Filtro Wega fixado! Lip sob MDF + aba sobre frame + batente na borda = preso em 3 faces.",
    show: { mdf: true, slots: false, filter: true, clips: true } }
];

let step = 0;
let scene, camera, renderer;
let groups = {};
let isDragging = false, prevMouse = { x: 0, y: 0 };
let spherical = { phi: 0.8, theta: 0.6, radius: 4.5 };

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x263238);
  
  camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 0.1, 100);
  
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  document.getElementById('c').appendChild(renderer.domElement);
  
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const dl1 = new THREE.DirectionalLight(0xffffff, 0.7);
  dl1.position.set(5, 8, 6);
  scene.add(dl1);
  const dl2 = new THREE.DirectionalLight(0xffffff, 0.3);
  dl2.position.set(-4, 4, -5);
  scene.add(dl2);
  
  const grid = new THREE.GridHelper(6, 12, 0x546e7a, 0x37474f);
  grid.position.y = -T - 0.02;
  scene.add(grid);
  
  buildMDF();
  buildSlots();
  buildFilter();
  buildClips();
  
  showStep();
  setupControls();
  window.addEventListener('resize', onResize);
  animate();
}

function buildMDF() {
  const mat = new THREE.MeshPhongMaterial({ color: 0xCD853F, transparent: true, opacity: 0.9 });
  const g = new THREE.Group();
  
  const bLeft = HOLE_X1;
  const bRight = W - HOLE_X2;
  const bBottom = HOLE_Z1;
  const bTop = H - HOLE_Z2;
  
  g.add(box(W, T, bBottom, mat)).position.set(W/2, -T/2, bBottom/2);
  g.add(box(W, T, bTop, mat)).position.set(W/2, -T/2, H - bTop/2);
  g.add(box(bLeft, T, HOLE_H, mat)).position.set(bLeft/2, -T/2, (HOLE_Z1 + HOLE_Z2)/2);
  g.add(box(bRight, T, HOLE_H, mat)).position.set(W - bRight/2, -T/2, (HOLE_Z1 + HOLE_Z2)/2);
  
  scene.add(g);
  groups.mdf = g;
}

function buildSlots() {
  const mat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
  const g = new THREE.Group();
  
  // Sem slots nem entalhes â€” clips com lip nÃ£o precisam furar o MDF
  
  scene.add(g);
  groups.slots = g;
}

function buildFilter() {
  const g = new THREE.Group();
  const centerX = W/2, centerZ = H/2;
  
  // Corpo do filtro (cinza escuro) â€” passa pelo furo 220Ã—164
  const matBody = new THREE.MeshPhongMaterial({ color: 0x34495e, transparent: true, opacity: 0.6 });
  const innerW = FILT_W - BORDA_W*2;
  const innerH = FILT_H - BORDA_W*2;
  const innerT = FILT_T - BORDA_ESP;
  const body = box(innerW, innerT, innerH, matBody);
  body.position.set(centerX, innerT/2, centerZ);
  g.add(body);
  
  // Frame traseiro 246Ã—182Ã—10mm (repousa SOBRE o MDF)
  const matBorda = new THREE.MeshPhongMaterial({ color: 0x95a5a6, transparent: true, opacity: 0.8 });
  
  // Borda inferior
  const frameBordaY = (FRAME_H - FILT_H) / 2 + BORDA_W; // extensÃ£o do frame
  g.add(box(FRAME_W, BORDA_ESP, frameBordaY, matBorda)).position.set(centerX, FILT_T - BORDA_ESP/2, centerZ - FRAME_H/2 + frameBordaY/2);
  // Borda superior
  g.add(box(FRAME_W, BORDA_ESP, frameBordaY, matBorda)).position.set(centerX, FILT_T - BORDA_ESP/2, centerZ + FRAME_H/2 - frameBordaY/2);
  // Borda esquerda
  const frameBordaX = (FRAME_W - FILT_W) / 2 + BORDA_W;
  g.add(box(frameBordaX, BORDA_ESP, FRAME_H - frameBordaY*2, matBorda)).position.set(centerX - FRAME_W/2 + frameBordaX/2, FILT_T - BORDA_ESP/2, centerZ);
  // Borda direita
  g.add(box(frameBordaX, BORDA_ESP, FRAME_H - frameBordaY*2, matBorda)).position.set(centerX + FRAME_W/2 - frameBordaX/2, FILT_T - BORDA_ESP/2, centerZ);
  
  scene.add(g);
  groups.filter = g;
}

function buildClips() {
  const g = new THREE.Group();
  
  CLIPS.forEach(c => {
    const clip = makeClip();
    clip.position.set(c.x, 0, c.z);
    clip.rotation.y = c.rot;
    g.add(clip);
  });
  
  scene.add(g);
  groups.clips = g;
}

function makeClip() {
  const g = new THREE.Group();
  const mat = new THREE.MeshPhongMaterial({ color: 0xe67e22 });
  const bmat = new THREE.MeshPhongMaterial({ color: 0xd35400 });
  
  const wallH = LIP_ESP + T + BORDA_ESP + FOLGA + ABA_ESP;
  
  // Parede (lado furo, Y positivo = no espaÃ§o do furo)
  g.add(box(CLIP_LARG, CLIP_PAREDE, wallH, mat)).position.set(0, CLIP_PAREDE/2, (BORDA_ESP + FOLGA + ABA_ESP - T - LIP_ESP)/2);
  
  // Lip (engancha sob o MDF, +Y = MDF sÃ³lido)
  g.add(box(CLIP_LARG, LIP_PROF, LIP_ESP, mat)).position.set(0, -LIP_PROF/2, -T - LIP_ESP/2);
  
  // Aba (sobre o frame, +Y = para fora do furo)
  g.add(box(CLIP_LARG, ABA_COMP + CLIP_PAREDE, ABA_ESP, mat)).position.set(0, -(ABA_COMP - CLIP_PAREDE)/2, BORDA_ESP + FOLGA + ABA_ESP/2);
  
  // Batente (na borda externa do frame)
  const WEGA_BORDA_LARG = 0.095; // 9.5mm
  const batW = ABA_COMP - WEGA_BORDA_LARG; // 2mm
  const batH = BATENTE_ALT + ABA_ESP;
  g.add(box(CLIP_LARG, batW, batH, bmat)).position.set(0, -(WEGA_BORDA_LARG + batW/2), BORDA_ESP + FOLGA + ABA_ESP/2 - BATENTE_ALT/2);
  
  return g;
}

function box(w, h, d, mat) {
  return new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
}

function showStep() {
  const s = STEPS[step];
  document.getElementById('sT').textContent = s.title;
  document.getElementById('sD').textContent = s.desc;
  
  groups.mdf.visible = s.show.mdf;
  groups.slots.visible = s.show.slots;
  groups.filter.visible = s.show.filter;
  groups.clips.visible = s.show.clips;
  
  groups.filter.position.y = 0;
  groups.clips.children.forEach(c => c.position.y = 0);
  
  if (step === 1) animateFilter();
  if (step === 2) animateClips();
}

function animateFilter() {
  groups.filter.position.y = 0.5;
  function tick() {
    if (step !== 1) return;
    if (groups.filter.position.y > 0.002) {
      groups.filter.position.y -= 0.006;
      requestAnimationFrame(tick);
    } else {
      groups.filter.position.y = 0;
    }
  }
  tick();
}

function animateClips() {
  const clips = groups.clips.children;
  clips.forEach((c, i) => c.position.y = 0.4 + i * 0.02);
  let t = 0;
  function tick() {
    if (step !== 2) { clips.forEach(c => c.position.y = 0); return; }
    t += 0.02;
    let allDone = true;
    clips.forEach((c, i) => {
      const delay = i * 0.1;
      const progress = Math.min(1, Math.max(0, (t - delay) * 2));
      c.position.y = 0.4 * (1 - progress * progress * progress);
      if (progress < 1) allDone = false;
    });
    if (!allDone) requestAnimationFrame(tick);
    else clips.forEach(c => c.position.y = 0);
  }
  tick();
}

function next() { if (step < STEPS.length - 1) { step++; showStep(); } }
function prev() { if (step > 0) { step--; showStep(); } }

function setupControls() {
  const el = renderer.domElement;
  el.addEventListener('pointerdown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
    el.setPointerCapture(e.pointerId);
  });
  el.addEventListener('pointermove', e => {
    if (!isDragging) return;
    spherical.phi -= (e.clientX - prevMouse.x) * 0.005;
    spherical.theta = Math.max(0.1, Math.min(1.5, spherical.theta - (e.clientY - prevMouse.y) * 0.005));
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  el.addEventListener('pointerup', () => isDragging = false);
  el.addEventListener('wheel', e => {
    spherical.radius = Math.max(2, Math.min(10, spherical.radius + e.deltaY * 0.003));
  }, { passive: true });
  document.addEventListener('keydown', e => {
    if (e.key === 'ArrowRight') next();
    if (e.key === 'ArrowLeft') prev();
  });
}

function onResize() {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  
  const cx = W / 2, cz = H / 2;
  camera.position.set(
    cx + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta),
    spherical.radius * Math.sin(spherical.theta),
    cz + spherical.radius * Math.cos(spherical.phi) * Math.cos(spherical.theta)
  );
  camera.lookAt(cx, 0.05, cz);
  
  renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
