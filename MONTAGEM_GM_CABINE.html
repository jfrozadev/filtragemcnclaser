<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Montagem ‚Äî Filtro GM Cabine + Clips Snap-fit</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',system-ui,sans-serif;background:#1a1a2e;overflow:hidden}
#c{width:100vw;height:100vh;display:block}
#panel{position:absolute;top:10px;left:10px;background:rgba(255,255,255,.97);padding:14px;border-radius:10px;max-width:320px;box-shadow:0 8px 30px rgba(0,0,0,.4);max-height:calc(100vh - 20px);overflow-y:auto}
h1{font-size:.95rem;color:#2c3e50;margin-bottom:2px}
.sub{font-size:.6rem;color:#7f8c8d;margin-bottom:8px}
.step{background:#f0f7ff;padding:10px;border-radius:8px;margin-bottom:8px;border-left:3px solid #3498db}
.step h2{font-size:.78rem;color:#2c3e50;margin-bottom:3px}
.step p{font-size:.65rem;color:#555;line-height:1.35}
.nav{display:flex;gap:6px;margin-bottom:8px}
.nav button{flex:1;padding:7px;border:none;border-radius:6px;font-size:.72rem;font-weight:600;cursor:pointer;transition:.15s}
.bp{background:#ecf0f1;color:#2c3e50}.bp:hover{background:#d5dbdb}
.bn{background:#3498db;color:#fff}.bn:hover{background:#2980b9}
.sec{background:#f8f9fa;border:1px solid #dee2e6;border-radius:6px;padding:8px;margin-bottom:8px}
.sec h3{font-size:.68rem;color:#495057;margin-bottom:4px}
.sec pre{font-size:.58rem;line-height:1.3;color:#333;font-family:'Cascadia Code','Consolas',monospace}
.specs{font-size:.6rem;color:#666;margin-bottom:6px}
.specs table{width:100%;border-collapse:collapse}
.specs td{padding:1px 4px}.specs .l{color:#888}.specs .v{font-weight:600;text-align:right}
.legend{display:flex;gap:8px;flex-wrap:wrap}
.legend span{display:flex;align-items:center;gap:3px;font-size:.58rem}
.legend i{width:10px;height:10px;border-radius:2px;display:inline-block}
#info{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,.85);padding:5px 14px;border-radius:6px;font-size:.62rem;white-space:nowrap}
</style>
</head>
<body>
<div id="c"></div>
<div id="panel">
  <h1>üîß Montagem ‚Äî GM Cabine</h1>
  <div class="sub">Divis√≥ria 244√ó240mm ¬∑ Furo 213√ó200mm ¬∑ 8 clips ultra-finos</div>
  <div class="step"><h2 id="sT"></h2><p id="sD"></p></div>
  <div class="nav">
    <button class="bp" onclick="prev()">‚Üê Anterior</button>
    <button class="bn" onclick="next()">Pr√≥ximo ‚Üí</button>
  </div>
  <div class="sec">
    <h3>Se√ß√£o transversal do clip</h3>
    <pre>
       ‚îå‚îÄ‚îÄ‚îÄ aba 8mm ‚îÄ‚îÄ‚îÄ‚îê   (0.8mm ultra-fina)
       ‚îÇ FILTRO 20mm   ‚îÇ   (borda 5√ó2mm papel√£o)
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê MDF 3mm ‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê
       ‚îÇ   base 8mm    ‚îÇ
       ‚îî‚îÄ‚î§dente‚îú‚îÄ‚îÄ‚îÄ‚î§dente‚îú‚îÄ‚îò
    </pre>
  </div>
  <div class="specs"><table>
    <tr><td class="l">Filtro:</td><td class="v">GM Cabine ‚Äî 223√ó210√ó20mm</td></tr>
    <tr><td class="l">Borda:</td><td class="v">5√ó2mm (papel√£o fino)</td></tr>
    <tr><td class="l">Furo MDF:</td><td class="v">213√ó200mm</td></tr>
    <tr><td class="l">Clips:</td><td class="v">8√ó (larg 25mm, aba 8mm)</td></tr>
  </table></div>
  <div class="legend">
    <span><i style="background:#CD853F"></i>MDF</span>
    <span><i style="background:#9b59b6"></i>Filtro</span>
    <span><i style="background:#e67e22"></i>Clip</span>
    <span><i style="background:#c0392b"></i>Dentes</span>
    <span><i style="background:#222"></i>Slots</span>
  </div>
</div>
<div id="info">üñ±Ô∏è Arrastar = Girar ¬∑ Scroll = Zoom ¬∑ ‚Üê ‚Üí = Passos</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ===== DADOS DO NC E SCAD ===== */
// Escala: 1 unidade = 100mm

// MDF 244√ó240√ó3mm
const W = 2.44, H = 2.40, T = 0.03;

// Furo 213√ó200mm (X: 15.5-228.5, Y: 20-220)
const HOLE_X1 = 0.155, HOLE_X2 = 2.285;
const HOLE_Z1 = 0.20, HOLE_Z2 = 2.20;
const HOLE_W = HOLE_X2 - HOLE_X1;  // 2.13
const HOLE_H = HOLE_Z2 - HOLE_Z1;  // 2.00

// Filtro GM Cabine 223√ó210√ó20mm (borda 5√ó2mm)
const FILT_W = 2.23, FILT_H = 2.10, FILT_T = 0.20;
const BORDA_W = 0.05, BORDA_ESP = 0.02;

// Clip (CLIP_GM_CABINE.scad)
const CLIP_LARG = 0.25;    // 25mm
const CLIP_PAREDE = 0.016; // 1.6mm
const ABA_COMP = 0.08;     // 8mm
const ABA_ESP = 0.008;     // 0.8mm ultra-fina
const BASE_PROF = 0.08;    // 8mm
const DENTE_POS = 0.06;    // 6mm

// Posi√ß√µes dos 8 clips (NC: X=85,159 e Y=90,150)
const CLIPS = [
  // Inferior (Z=0.20)
  { x: 0.85, z: HOLE_Z1, rot: Math.PI },
  { x: 1.59, z: HOLE_Z1, rot: Math.PI },
  // Superior (Z=2.20)
  { x: 0.85, z: HOLE_Z2, rot: 0 },
  { x: 1.59, z: HOLE_Z2, rot: 0 },
  // Esquerdo (X=0.155)
  { x: HOLE_X1, z: 0.90, rot: -Math.PI/2 },
  { x: HOLE_X1, z: 1.50, rot: -Math.PI/2 },
  // Direito (X=2.285)
  { x: HOLE_X2, z: 0.90, rot: Math.PI/2 },
  { x: HOLE_X2, z: 1.50, rot: Math.PI/2 }
];

// Slots
const SLOTS_H = [
  [0.79, 0.11], [0.91, 0.11], [1.53, 0.11], [1.65, 0.11],
  [0.79, 2.29], [0.91, 2.29], [1.53, 2.29], [1.65, 2.29]
];
const SLOTS_V = [
  [0.065, 0.84], [0.065, 0.96], [0.065, 1.44], [0.065, 1.56],
  [2.375, 0.84], [2.375, 0.96], [2.375, 1.44], [2.375, 1.56]
];

const STEPS = [
  { title: "Etapa 1/4 ‚Äî Divis√≥ria MDF",
    desc: "Placa MDF 244√ó240√ó3mm. Furo 213√ó200mm para o filtro GM Cabine maior.",
    show: { mdf: true, slots: true, filter: false, clips: false } },
  { title: "Etapa 2/4 ‚Äî Posicionar Filtro GM",
    desc: "Coloque o filtro GM Cabine (223√ó210√ó20mm). Borda de papel√£o fino 5√ó2mm fica sobre o MDF.",
    show: { mdf: true, slots: true, filter: true, clips: false } },
  { title: "Etapa 3/4 ‚Äî Encaixar os 8 Clips",
    desc: "Clips com aba ultra-fina (0.8mm) e 3 ranhuras de flex√£o. Pressione at√© os dentes encaixarem.",
    show: { mdf: true, slots: true, filter: true, clips: true } },
  { title: "Etapa 4/4 ‚Äî Montagem Completa",
    desc: "‚úÖ Filtro GM Cabine fixado! Clips prendem pela borda de papel√£o fina.",
    show: { mdf: true, slots: true, filter: true, clips: true } }
];

let step = 0;
let scene, camera, renderer;
let groups = {};
let isDragging = false, prevMouse = { x: 0, y: 0 };
let spherical = { phi: 0.8, theta: 0.6, radius: 4.5 };

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x263238);
  
  camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 0.1, 100);
  
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  document.getElementById('c').appendChild(renderer.domElement);
  
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const dl1 = new THREE.DirectionalLight(0xffffff, 0.7);
  dl1.position.set(5, 8, 6);
  scene.add(dl1);
  const dl2 = new THREE.DirectionalLight(0xffffff, 0.3);
  dl2.position.set(-4, 4, -5);
  scene.add(dl2);
  
  const grid = new THREE.GridHelper(6, 12, 0x546e7a, 0x37474f);
  grid.position.y = -T - 0.02;
  scene.add(grid);
  
  buildMDF();
  buildSlots();
  buildFilter();
  buildClips();
  
  showStep();
  setupControls();
  window.addEventListener('resize', onResize);
  animate();
}

function buildMDF() {
  const mat = new THREE.MeshPhongMaterial({ color: 0xCD853F, transparent: true, opacity: 0.9 });
  const g = new THREE.Group();
  
  const bLeft = HOLE_X1;
  const bRight = W - HOLE_X2;
  const bBottom = HOLE_Z1;
  const bTop = H - HOLE_Z2;
  
  g.add(box(W, T, bBottom, mat)).position.set(W/2, -T/2, bBottom/2);
  g.add(box(W, T, bTop, mat)).position.set(W/2, -T/2, H - bTop/2);
  g.add(box(bLeft, T, HOLE_H, mat)).position.set(bLeft/2, -T/2, H/2);
  g.add(box(bRight, T, HOLE_H, mat)).position.set(W - bRight/2, -T/2, H/2);
  
  scene.add(g);
  groups.mdf = g;
}

function buildSlots() {
  const mat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
  const g = new THREE.Group();
  
  SLOTS_H.forEach(([x, z]) => {
    g.add(box(0.10, T + 0.002, 0.02, mat)).position.set(x, -T/2, z);
  });
  SLOTS_V.forEach(([x, z]) => {
    g.add(box(0.02, T + 0.002, 0.10, mat)).position.set(x, -T/2, z);
  });
  
  scene.add(g);
  groups.slots = g;
}

function buildFilter() {
  const g = new THREE.Group();
  
  // Corpo do filtro (roxo)
  const matBody = new THREE.MeshPhongMaterial({ color: 0x9b59b6, transparent: true, opacity: 0.5 });
  const body = box(FILT_W - BORDA_W*2, FILT_T - BORDA_ESP, FILT_H - BORDA_W*2, matBody);
  body.position.set(W/2, FILT_T/2, H/2);
  g.add(body);
  
  // Borda de papel√£o (mais clara)
  const matBorda = new THREE.MeshPhongMaterial({ color: 0xd4a574, transparent: true, opacity: 0.7 });
  const bordaH = BORDA_ESP;
  const bordaFrame = new THREE.Group();
  
  // Borda inferior
  bordaFrame.add(box(FILT_W, bordaH, BORDA_W, matBorda)).position.set(W/2, FILT_T - bordaH/2, H/2 - FILT_H/2 + BORDA_W/2);
  // Borda superior
  bordaFrame.add(box(FILT_W, bordaH, BORDA_W, matBorda)).position.set(W/2, FILT_T - bordaH/2, H/2 + FILT_H/2 - BORDA_W/2);
  // Borda esquerda
  bordaFrame.add(box(BORDA_W, bordaH, FILT_H - BORDA_W*2, matBorda)).position.set(W/2 - FILT_W/2 + BORDA_W/2, FILT_T - bordaH/2, H/2);
  // Borda direita
  bordaFrame.add(box(BORDA_W, bordaH, FILT_H - BORDA_W*2, matBorda)).position.set(W/2 + FILT_W/2 - BORDA_W/2, FILT_T - bordaH/2, H/2);
  g.add(bordaFrame);
  
  scene.add(g);
  groups.filter = g;
}

function buildClips() {
  const g = new THREE.Group();
  
  CLIPS.forEach(c => {
    const clip = makeClip();
    clip.position.set(c.x, 0, c.z);
    clip.rotation.y = c.rot;
    g.add(clip);
  });
  
  scene.add(g);
  groups.clips = g;
}

function makeClip() {
  const g = new THREE.Group();
  const mat = new THREE.MeshPhongMaterial({ color: 0xe67e22 });
  const dmat = new THREE.MeshPhongMaterial({ color: 0xc0392b });
  
  const wallH = T + BORDA_ESP + ABA_ESP + 0.01;
  
  // Parede
  g.add(box(CLIP_LARG, CLIP_PAREDE, wallH, mat)).position.set(0, -CLIP_PAREDE/2, BORDA_ESP/2 - T/2);
  
  // Base
  g.add(box(CLIP_LARG, BASE_PROF, CLIP_PAREDE, mat)).position.set(0, -BASE_PROF/2, -T - CLIP_PAREDE/2);
  
  // Aba (ultra-fina com ranhuras)
  g.add(box(CLIP_LARG, ABA_COMP, ABA_ESP, mat)).position.set(0, -ABA_COMP/2, BORDA_ESP + ABA_ESP/2);
  
  // 3 ranhuras de flex√£o na aba
  const rmat = new THREE.MeshPhongMaterial({ color: 0xd35400 });
  for (let r = -1; r <= 1; r++) {
    const ranhura = box(0.008, ABA_COMP * 0.7, ABA_ESP + 0.001, rmat);
    ranhura.position.set(r * 0.08, -ABA_COMP * 0.4, BORDA_ESP + ABA_ESP/2);
    g.add(ranhura);
  }
  
  // 2 Dentes
  for (let d of [-1, 1]) {
    const tooth = box(0.08, 0.02, 0.012, dmat);
    tooth.position.set(d * DENTE_POS, -BASE_PROF + 0.01, -T + 0.006);
    g.add(tooth);
  }
  
  return g;
}

function box(w, h, d, mat) {
  return new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
}

function showStep() {
  const s = STEPS[step];
  document.getElementById('sT').textContent = s.title;
  document.getElementById('sD').textContent = s.desc;
  
  groups.mdf.visible = s.show.mdf;
  groups.slots.visible = s.show.slots;
  groups.filter.visible = s.show.filter;
  groups.clips.visible = s.show.clips;
  
  groups.filter.position.y = 0;
  groups.clips.children.forEach(c => c.position.y = 0);
  
  if (step === 1) animateFilter();
  if (step === 2) animateClips();
}

function animateFilter() {
  groups.filter.position.y = 0.4;
  function tick() {
    if (step !== 1) return;
    if (groups.filter.position.y > 0.002) {
      groups.filter.position.y -= 0.005;
      requestAnimationFrame(tick);
    } else {
      groups.filter.position.y = 0;
    }
  }
  tick();
}

function animateClips() {
  const clips = groups.clips.children;
  clips.forEach((c, i) => c.position.y = 0.35 + i * 0.02);
  let t = 0;
  function tick() {
    if (step !== 2) { clips.forEach(c => c.position.y = 0); return; }
    t += 0.02;
    let allDone = true;
    clips.forEach((c, i) => {
      const delay = i * 0.1;
      const progress = Math.min(1, Math.max(0, (t - delay) * 2));
      c.position.y = 0.35 * (1 - progress * progress * progress);
      if (progress < 1) allDone = false;
    });
    if (!allDone) requestAnimationFrame(tick);
    else clips.forEach(c => c.position.y = 0);
  }
  tick();
}

function next() { if (step < STEPS.length - 1) { step++; showStep(); } }
function prev() { if (step > 0) { step--; showStep(); } }

function setupControls() {
  const el = renderer.domElement;
  el.addEventListener('pointerdown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
    el.setPointerCapture(e.pointerId);
  });
  el.addEventListener('pointermove', e => {
    if (!isDragging) return;
    spherical.phi -= (e.clientX - prevMouse.x) * 0.005;
    spherical.theta = Math.max(0.1, Math.min(1.5, spherical.theta - (e.clientY - prevMouse.y) * 0.005));
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  el.addEventListener('pointerup', () => isDragging = false);
  el.addEventListener('wheel', e => {
    spherical.radius = Math.max(2, Math.min(10, spherical.radius + e.deltaY * 0.003));
  }, { passive: true });
  document.addEventListener('keydown', e => {
    if (e.key === 'ArrowRight') next();
    if (e.key === 'ArrowLeft') prev();
  });
}

function onResize() {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  
  const cx = W / 2, cz = H / 2;
  camera.position.set(
    cx + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta),
    spherical.radius * Math.sin(spherical.theta),
    cz + spherical.radius * Math.cos(spherical.phi) * Math.cos(spherical.theta)
  );
  camera.lookAt(cx, 0.05, cz);
  
  renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
