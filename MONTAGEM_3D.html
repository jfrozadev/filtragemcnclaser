<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montagem Passo a Passo - Caixa de Filtragem</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #1a1a2e; overflow: hidden; }
        #container { width: 100vw; height: 100vh; }
        
        #panel {
            position: absolute; top: 15px; left: 15px;
            background: rgba(255,255,255,0.97); padding: 18px;
            border-radius: 12px; max-width: 320px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }
        
        h1 { font-size: 1.1rem; color: #2c3e50; margin-bottom: 5px; }
        .subtitle { font-size: 0.65rem; color: #7f8c8d; margin-bottom: 12px; }
        
        .step-indicator {
            display: flex; justify-content: space-between; align-items: center;
            background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 12px;
        }
        .step-num { font-size: 2rem; font-weight: bold; color: #3498db; }
        .step-title { font-size: 0.85rem; font-weight: 600; color: #2c3e50; }
        .step-desc { font-size: 0.7rem; color: #7f8c8d; margin-top: 2px; }
        
        .nav-buttons { display: flex; gap: 8px; margin-bottom: 15px; }
        .nav-buttons button {
            flex: 1; padding: 10px; border: none; border-radius: 6px;
            font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
        }
        .btn-prev { background: #ecf0f1; color: #2c3e50; }
        .btn-next { background: #3498db; color: white; }
        .btn-prev:hover { background: #d5dbdb; }
        .btn-next:hover { background: #2980b9; }
        .btn-disabled { opacity: 0.5; cursor: not-allowed; }
        
        .progress-bar {
            height: 6px; background: #ecf0f1; border-radius: 3px; margin-bottom: 15px; overflow: hidden;
        }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); transition: width 0.3s; }
        
        .section { margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #eee; }
        .section-title { font-size: 0.7rem; font-weight: 600; color: #555; margin-bottom: 8px; }
        
        .encaixe-info {
            background: #e8f6ff; padding: 10px; border-radius: 6px;
            border-left: 3px solid #3498db; font-size: 0.68rem;
        }
        .encaixe-info.warning { background: #fff3e0; border-color: #f39c12; }
        .encaixe-info.success { background: #e8f5e9; border-color: #27ae60; }
        .encaixe-title { font-weight: 600; margin-bottom: 4px; }
        
        .view-buttons { display: flex; flex-wrap: wrap; gap: 4px; }
        .view-buttons button {
            padding: 6px 10px; border: none; border-radius: 4px;
            font-size: 0.65rem; cursor: pointer; background: #ecf0f1; color: #2c3e50;
        }
        .view-buttons button:hover { background: #3498db; color: white; }
        .view-buttons button.active { background: #3498db; color: white; }
        
        .legend { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.6rem; }
        .legend-color { width: 14px; height: 14px; border-radius: 3px; }
        
        #info {
            position: absolute; bottom: 15px; left: 15px;
            background: rgba(255,255,255,0.9); padding: 8px 14px;
            border-radius: 6px; font-size: 0.7rem;
        }
        
        #dimensions {
            position: absolute; bottom: 15px; right: 15px;
            background: rgba(255,255,255,0.95); padding: 12px;
            border-radius: 8px; font-size: 0.65rem;
        }
        #dimensions table { border-collapse: collapse; }
        #dimensions td { padding: 3px 8px; }
        #dimensions .label { color: #666; }
        #dimensions .val { font-weight: 600; text-align: right; }
        #dimensions .highlight { color: #27ae60; }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="panel">
        <h1>üîß Montagem Passo a Passo</h1>
        <div class="subtitle">Caixa de Filtragem 250√ó250√ó250mm - Valida√ß√£o de Encaixes</div>
        
        <div class="step-indicator">
            <div>
                <div class="step-num" id="stepNum">1</div>
            </div>
            <div style="flex:1; margin-left: 15px;">
                <div class="step-title" id="stepTitle">Base</div>
                <div class="step-desc" id="stepDesc">Posicione a base na mesa</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 9%"></div>
        </div>
        
        <div class="nav-buttons">
            <button class="btn-prev" id="btnPrev" onclick="prevStep()">‚Üê Anterior</button>
            <button class="btn-next" id="btnNext" onclick="nextStep()">Pr√≥ximo ‚Üí</button>
        </div>
        
        <div class="encaixe-info" id="encaixeInfo">
            <div class="encaixe-title">üìê Encaixe:</div>
            <div id="encaixeDesc">Base 250√ó250mm - superf√≠cie plana</div>
        </div>
        
        <div class="section">
            <div class="section-title">üëÅÔ∏è Visualiza√ß√£o</div>
            <div class="view-buttons">
                <button onclick="resetView()">Reset</button>
                <button onclick="viewFront()">Frente</button>
                <button onclick="viewBack()">Tr√°s</button>
                <button onclick="viewSide()">Lado</button>
                <button onclick="viewTop()">Topo</button>
                <button onclick="viewInside()">Dentro</button>
            </div>
            <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                <label style="font-size: 0.65rem; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" id="chkExplode" onchange="toggleExplode()"> Explodir pe√ßas
                </label>
                <label style="font-size: 0.65rem; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" id="chkWireframe" onchange="toggleWireframe()"> Wireframe
                </label>
                <label style="font-size: 0.65rem; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" id="chkAutoRotate" onchange="toggleAutoRotate()"> Auto-girar
                </label>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">üé® Legenda</div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#8B4513"></div>MDF 3mm</div>
                <div class="legend-item"><div class="legend-color" style="background:#e74c3c"></div>Dentes (macho)</div>
                <div class="legend-item"><div class="legend-color" style="background:#3498db"></div>Ranhuras (f√™mea)</div>
                <div class="legend-item"><div class="legend-color" style="background:#2ecc71"></div>Slots divis√≥rias</div>
                <div class="legend-item"><div class="legend-color" style="background:#f39c12"></div>Abas/Encaixes</div>
                <div class="legend-item"><div class="legend-color" style="background:#00bcd4"></div>Snap-fit clips</div>
                <div class="legend-item"><div class="legend-color" style="background:#A0522D"></div>Caixa carv√£o</div>
                <div class="legend-item"><div class="legend-color" style="background:#9b59b6"></div>Pe√ßa atual</div>
            </div>
        </div>
    </div>
    
    <div id="info">üñ±Ô∏è Arrastar = Girar | Scroll = Zoom | Shift+Arrastar = Pan | Setas ‚Üê ‚Üí = Passos</div>
    
    <div id="dimensions">
        <table>
            <tr><td class="label">Caixa:</td><td class="val">250√ó250√ó250mm</td></tr>
            <tr><td class="label">MDF:</td><td class="val">3mm</td></tr>
            <tr><td class="label">Dentes:</td><td class="val">25mm largura</td></tr>
            <tr><td class="label">Slots:</td><td class="val">4√ó40mm</td></tr>
            <tr><td class="label">HEPA:</td><td class="val highlight">110√ó140mm ‚úì</td></tr>
        </table>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let parts = {};
        let currentStep = 0;
        let explodeMode = false;
        let wireframeMode = false;
        let autoRotate = false;
        
        const S = 2.5;  // 250mm
        const T = 0.03; // 3mm
        const TOOTH = 0.25; // 25mm
        
        const COLORS = {
            mdf: 0xCD853F,      // Mais claro
            mdfLight: 0xDEB887, // Bege
            teeth: 0xe74c3c,
            slots: 0x3498db,
            divSlots: 0x2ecc71,
            abas: 0xf39c12,
            current: 0x9b59b6,
            ghost: 0xcccccc,
            highlight: 0xff6b6b,
            screw: 0x7f8c8d,
            screwHead: 0x95a5a6
        };
        
        // Fun√ß√£o para criar parafuso 3D realista
        function createScrew(length = 0.15, headRadius = 0.04, shaftRadius = 0.015) {
            const group = new THREE.Group();
            
            // Cabe√ßa do parafuso (Phillips/cruz)
            const headMat = new THREE.MeshPhongMaterial({ 
                color: COLORS.screwHead, 
                metalness: 0.8,
                shininess: 100
            });
            const headGeom = new THREE.CylinderGeometry(headRadius, headRadius * 0.9, 0.025, 16);
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = length / 2 + 0.0125;
            group.add(head);
            
            // Fenda Phillips (cruz) na cabe√ßa
            const slotMat = new THREE.MeshBasicMaterial({ color: 0x2c3e50 });
            const slot1 = new THREE.Mesh(new THREE.BoxGeometry(headRadius * 1.4, 0.03, 0.008), slotMat);
            slot1.position.y = length / 2 + 0.026;
            group.add(slot1);
            const slot2 = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.03, headRadius * 1.4), slotMat);
            slot2.position.y = length / 2 + 0.026;
            group.add(slot2);
            
            // Corpo do parafuso (rosca)
            const shaftMat = new THREE.MeshPhongMaterial({ 
                color: COLORS.screw,
                metalness: 0.6,
                shininess: 80
            });
            const shaftGeom = new THREE.CylinderGeometry(shaftRadius, shaftRadius * 0.7, length, 12);
            const shaft = new THREE.Mesh(shaftGeom, shaftMat);
            group.add(shaft);
            
            // Rosca visual (espiral simplificada)
            const threadMat = new THREE.MeshBasicMaterial({ color: 0x5a6a7a });
            for (let i = 0; i < 6; i++) {
                const threadRing = new THREE.Mesh(
                    new THREE.TorusGeometry(shaftRadius * 1.1, 0.003, 4, 16),
                    threadMat
                );
                threadRing.rotation.x = Math.PI / 2;
                threadRing.position.y = -length / 2 + 0.02 + i * 0.02;
                group.add(threadRing);
            }
            
            return group;
        }
        
        // Fun√ß√£o para criar p√© de borracha
        function createRubberFoot() {
            const group = new THREE.Group();
            
            // P√© de borracha (cilindro achatado)
            const footMat = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a1a,
                shininess: 20
            });
            const foot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.07, 0.03, 16),
                footMat
            );
            foot.position.y = -0.015;
            group.add(foot);
            
            // Parafuso que fixa o p√©
            const screw = createScrew(0.08, 0.03, 0.012);
            screw.rotation.x = Math.PI; // Virado para baixo
            screw.position.y = 0.02;
            group.add(screw);
            
            return group;
        }
        
        const steps = [
            {
                num: 1, title: "Base", desc: "Posicione a base na mesa de trabalho",
                encaixe: "Base 250√ó250mm com 4 p√©s de borracha nos cantos (j√° instalados com parafusos M3).",
                type: "info", parts: ['base'],
                camera: { pos: [4, 2, 4], look: [1.25, 0.1, 1.25] }
            },
            {
                num: 2, title: "Lateral Esquerda", desc: "Encaixe a lateral esquerda sobre a base",
                encaixe: "A lateral (250√ó250mm) fica EM P√â sobre a base. Fixe com cola PVA na borda.",
                type: "warning", parts: ['base', 'latEsq'],
                camera: { pos: [3, 2.5, 4], look: [1.25, 1.3, 0.5] }
            },
            {
                num: 3, title: "Lateral Direita", desc: "Encaixe a lateral direita sobre a base",
                encaixe: "Paralela √† esquerda. Dist√¢ncia interna: 244mm (espa√ßo para frontal/traseira).",
                type: "info", parts: ['base', 'latEsq', 'latDir'],
                camera: { pos: [4, 2.5, 3], look: [1.25, 1.3, 1.25] }
            },
            {
                num: 4, title: "Frontal (Entrada)", desc: "Encaixe o frontal entre as laterais",
                encaixe: "‚ö†Ô∏è CR√çTICO: Os DENTES VERMELHOS do frontal entram nas RANHURAS AZUIS das laterais! Furo 70mm.",
                type: "success", parts: ['base', 'latEsq', 'latDir', 'frontal'],
                camera: { pos: [0, 2, 4], look: [0.3, 1.3, 1.25] }
            },
            {
                num: 5, title: "Traseira (Sa√≠da)", desc: "Encaixe a traseira entre as laterais",
                encaixe: "Igual ao frontal. DENTES entram nas RANHURAS das laterais. Furo de sa√≠da 150mm.",
                type: "success", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira'],
                camera: { pos: [4, 2.5, 2], look: [1.25, 1.3, 1.25] }
            },
            {
                num: 6, title: "Divis√≥ria Manta G3", desc: "Insira a divis√≥ria MANTA G3 (pr√©-filtro)",
                encaixe: "üîµ MANTA G3 - Pr√©-filtro 10mm espessura (colada + grampos). Posi√ß√£o X=15mm. Filtra part√≠culas grandes.",
                type: "info", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira', 'divMantaG3'],
                camera: { pos: [0.8, 2.5, 3.5], look: [0.15, 1.3, 1.25] }
            },
            {
                num: 7, title: "Divis√≥ria GM Bosch", desc: "Insira a divis√≥ria GM CABINE BOSCH",
                encaixe: "üü° GM CABINE BOSCH - Filtro cabine 20mm espessura. Posi√ß√£o X=40mm. Filtra part√≠culas m√©dias.",
                type: "info", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira', 'divMantaG3', 'divGM'],
                camera: { pos: [1.2, 2.5, 3.5], look: [0.40, 1.3, 1.25] }
            },
            {
                num: 8, title: "Divis√≥ria Wega", desc: "Insira a divis√≥ria WEGA (filtro motor)",
                encaixe: "üü¢ WEGA MOTOR - Filtro motor 45mm espessura. Posi√ß√£o X=90mm. Filtra part√≠culas finas.",
                type: "warning", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira', 'divMantaG3', 'divGM', 'divWega'],
                camera: { pos: [1.6, 2.5, 3.5], look: [0.90, 1.3, 1.25] }
            },
            {
                num: 9, title: "Divis√≥ria HEPA", desc: "Insira a divis√≥ria FILTRO HEPA",
                encaixe: "üî∑ FILTRO HEPA - 110√ó140√ó25mm. Posi√ß√£o X=120mm.",
                type: "success", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira', 'divMantaG3', 'divGM', 'divWega', 'divHepa'],
                camera: { pos: [2.2, 2.5, 3.5], look: [1.20, 1.3, 1.25] }
            },
            {
                num: 10, title: "Telas de Carv√£o", desc: "Insira as 2 telas de carv√£o nos slots das laterais",
                encaixe: "‚¨õ CARV√ÉO ATIVADO - 2 telas MDF 244√ó244mm (abertura 200√ó200mm) nos slots X=165mm e X=210mm + caixa MDF 4 lados com encaixe (13_CAIXA_CARVAO.nc). Tela alum√≠nio mosquiteira fixada com M3+arruela. ~500g carv√£o granulado.",
                type: "info", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira', 'divMantaG3', 'divGM', 'divWega', 'divHepa', 'gaveta'],
                camera: { pos: [4, 1.2, 2], look: [2.0, 0.2, 1.25] }
            },
            {
                num: 11, title: "Tampa", desc: "Feche com a tampa usando clips snap-fit",
                encaixe: "‚úÖ COMPLETO! Tampa 250√ó250mm fixada com clips snap-fit impressos em 3D (SNAP_TAMPA.scad). Sem parafusos!",
                type: "success", parts: ['base', 'latEsq', 'latDir', 'frontal', 'traseira', 'divMantaG3', 'divGM', 'divWega', 'divHepa', 'gaveta', 'tampa'],
                camera: { pos: [4, 3.5, 4], look: [1.25, 1.3, 1.25] }
            }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
            camera.position.set(5, 4, 5);
            camera.lookAt(1.25, 1, 1.25);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Ilumina√ß√£o melhorada
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);
            
            const backLight = new THREE.DirectionalLight(0x8ecae6, 0.2);
            backLight.position.set(0, -5, 0);
            scene.add(backLight);
            
            // Grid mais vis√≠vel
            const grid = new THREE.GridHelper(8, 16, 0x6c757d, 0x495057);
            grid.position.y = -0.01;
            scene.add(grid);
            
            // Eixos de refer√™ncia
            const axesHelper = new THREE.AxesHelper(0.5);
            axesHelper.position.set(-0.3, 0, -0.3);
            scene.add(axesHelper);
            
            // Carregar fonte para textos de identifica√ß√£o
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                window.loadedFont = font;
                // Recriar pe√ßas com fonte carregada
                createAllParts();
                updateStep();
            }, undefined, function() {
                // Erro ao carregar fonte - usar fallback com sprites
                console.log('Usando labels com sprites (fallback)');
            });
            
            // Criar pe√ßas inicialmente (com sprites como fallback)
            setTimeout(() => {
                if (Object.keys(parts).length === 0) {
                    createAllParts();
                    updateStep();
                }
            }, 100);
            
            setupMouse();
            
            window.onresize = () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            };
        }
        
        // Fun√ß√£o para criar texto de identifica√ß√£o (marca√ß√£o grifada)
        function createLabel(text, size = 0.12) {
            const group = new THREE.Group();
            
            if (window.loadedFont) {
                // Criar geometria do texto
                const textGeometry = new THREE.TextGeometry(text, {
                    font: window.loadedFont,
                    size: size,
                    height: 0.005,
                    curveSegments: 4,
                    bevelEnabled: false
                });
                textGeometry.center();
                
                // Material do texto - cor escura para parecer grifado/marcado
                const textMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.8
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                group.add(textMesh);
                
                // Adicionar sublinhado (grifo)
                const underlineGeom = new THREE.PlaneGeometry(text.length * size * 0.55, size * 0.08);
                const underlineMat = new THREE.MeshBasicMaterial({ 
                    color: 0x1a1a1a, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const underline = new THREE.Mesh(underlineGeom, underlineMat);
                underline.position.y = -size * 0.6;
                group.add(underline);
            } else {
                // Fallback: usar sprite com canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // Fundo transparente
                ctx.fillStyle = 'rgba(0,0,0,0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Texto grifado
                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#1a1a1a';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width/2, canvas.height/2 - 5);
                
                // Sublinhado (grifo)
                const textWidth = ctx.measureText(text).width;
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo((canvas.width - textWidth)/2, canvas.height/2 + 12);
                ctx.lineTo((canvas.width + textWidth)/2, canvas.height/2 + 12);
                ctx.stroke();
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(size * 4, size, 1);
                group.add(sprite);
            }
            
            return group;
        }
        
        function createAllParts() {
            // Limpar partes existentes
            Object.values(parts).forEach(p => {
                if (p && p.parent) scene.remove(p);
            });
            
            parts.base = createBase();
            scene.add(parts.base);
            
            parts.latEsq = createLateral('esq');
            scene.add(parts.latEsq);
            
            parts.latDir = createLateral('dir');
            scene.add(parts.latDir);
            
            parts.frontal = createFrontal();
            scene.add(parts.frontal);
            
            parts.traseira = createTraseira();
            scene.add(parts.traseira);
            
            parts.divMantaG3 = createDivisoria(0.15, 'mantag3');
            scene.add(parts.divMantaG3);
            
            parts.divGM = createDivisoria(0.40, 'gm');
            scene.add(parts.divGM);
            
            parts.divWega = createDivisoria(0.90, 'wega');
            scene.add(parts.divWega);
            
            parts.divHepa = createDivisoria(1.20, 'hepa');
            scene.add(parts.divHepa);
            
            parts.gaveta = createCarbonCompartment();
            scene.add(parts.gaveta);
            
            parts.tampa = createTampa();
            scene.add(parts.tampa);
            
            Object.values(parts).forEach(p => p.visible = false);
        }
        
        function createBase() {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color: COLORS.mdf, side: THREE.DoubleSide });
            const base = new THREE.Mesh(new THREE.BoxGeometry(S, T, S), mat);
            base.position.set(S/2, T/2, S/2);
            group.add(base);
            
            // Furos para os p√©s de borracha (4 cantos - 25mm das bordas)
            const holeMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const footPositions = [[0.25, 0.20], [2.25, 0.20], [0.25, 2.30], [2.25, 2.30]];
            
            footPositions.forEach(([x, z]) => {
                // Furo para p√©
                const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, T*2, 16), holeMat);
                hole.position.set(x, T/2, z);
                group.add(hole);
                
                // P√© de borracha com parafuso (embaixo da base)
                const foot = createRubberFoot();
                foot.position.set(x, 0, z);
                group.add(foot);
            });
            
            // ========================================
            // SNAP-FIT SLOTS NA BASE (mesmas posi√ß√µes que a tampa)
            // 8 slots para clips snap-fit na base
            // ========================================
            const snapSlotMat = new THREE.MeshPhongMaterial({ color: 0x00838f });
            // Posi√ß√µes dos slots snap-fit (22√ó2mm)
            const baseClipPositions = [
                [1.05, T*0.5], [1.45, T*0.5],     // Lat.esq
                [1.05, S-T*0.5], [1.45, S-T*0.5], // Lat.dir
                [T*0.5, 0.82], [T*0.5, 1.62],     // Frontal
                [S-T*0.5, 0.82], [S-T*0.5, 1.62]  // Traseira
            ];
            
            baseClipPositions.forEach(([x, z]) => {
                const slot = new THREE.Mesh(new THREE.BoxGeometry(0.02, T*2, 0.22), snapSlotMat);
                slot.position.set(x, T/2, z);
                group.add(slot);
            });
            
            // Marca√ß√£o interna - "BASE" no topo (lado interno)
            const label = createLabel('BASE', 0.15);
            label.rotation.x = -Math.PI/2;
            label.position.set(S/2, T + 0.01, S/2);
            group.add(label);
            
            return group;
        }
        
        function createLateral(side) {
            const group = new THREE.Group();
            const isLeft = side === 'esq';
            // Laterais ficam nas bordas: Z=T/2 (esquerda dentro) e Z=S-T/2 (direita dentro)
            const zPos = isLeft ? T/2 : S - T/2;
            
            const mat = new THREE.MeshPhongMaterial({ color: COLORS.mdf, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            // Lateral tem altura S (250mm) e largura S (250mm)
            const plate = new THREE.Mesh(new THREE.BoxGeometry(S, S, T), mat);
            plate.position.set(S/2, T + S/2, zPos);
            group.add(plate);
            
            // RANHURAS nas bordas X=0 e X=S (para frontal/traseira)
            const slotMat = new THREE.MeshPhongMaterial({ color: COLORS.slots, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 1) {
                    // Ranhura frontal (X pr√≥ximo a 0)
                    const slotF = new THREE.Mesh(new THREE.BoxGeometry(T*2, TOOTH*0.9, T*2), slotMat);
                    slotF.position.set(T, T + TOOTH/2 + i * TOOTH, zPos);
                    group.add(slotF);
                    
                    // Ranhura traseira (X pr√≥ximo a S)
                    const slotB = new THREE.Mesh(new THREE.BoxGeometry(T*2, TOOTH*0.9, T*2), slotMat);
                    slotB.position.set(S - T, T + TOOTH/2 + i * TOOTH, zPos);
                    group.add(slotB);
                }
            }
            
            // SLOTS para divis√≥rias (verde) - 6 posi√ß√µes (4 filtros + 2 telas carv√£o)
            const divSlotMat = new THREE.MeshPhongMaterial({ color: COLORS.divSlots, transparent: true, opacity: 0.9 });
            [0.15, 0.40, 0.90, 1.20, 1.65, 2.10].forEach(x => {
                const slotL = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.4, T*2), divSlotMat);
                slotL.position.set(x, T + 0.35, zPos);
                group.add(slotL);
                
                const slotU = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.4, T*2), divSlotMat);
                slotU.position.set(x, T + S - 0.35, zPos);
                group.add(slotU);
            });
            
            // SLOTS SNAP-FIT (ciano) - 22√ó2mm para clips snap-fit
            const snapSlotMat = new THREE.MeshPhongMaterial({ color: 0x00bcd4, transparent: true, opacity: 0.9 });
            [1.05, 1.45].forEach(x => {
                // Slot superior (Y=220mm = 2.20)
                const snapTop = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.22, T*2), snapSlotMat);
                snapTop.position.set(x, T + 2.20, zPos);
                group.add(snapTop);
                
                // Slot inferior (Y=30mm = 0.30)
                const snapBot = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.22, T*2), snapSlotMat);
                snapBot.position.set(x, T + 0.30, zPos);
                group.add(snapBot);
            });
            
            // Marca√ß√£o interna - identifica√ß√£o da lateral
            const labelText = isLeft ? 'LAT. ESQ' : 'LAT. DIR';
            const label = createLabel(labelText, 0.12);
            label.rotation.y = isLeft ? 0 : Math.PI; // Texto voltado para dentro
            label.position.set(S/2, T + S/2, isLeft ? zPos + 0.02 : zPos - 0.02);
            group.add(label);
            
            return group;
        }
        
        function createFrontal() {
            const group = new THREE.Group();
            const W = S - 2*T; // 244mm (largura interna entre as laterais)
            
            const mat = new THREE.MeshPhongMaterial({ color: COLORS.mdf, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            // Frontal fica em X=T/2, altura S, largura W (entre as laterais)
            const plate = new THREE.Mesh(new THREE.BoxGeometry(T, S, W), mat);
            plate.position.set(T/2, T + S/2, S/2);
            group.add(plate);
            
            // DENTES nas laterais (vermelho) - encaixam nas ranhuras azuis das laterais
            const toothMat = new THREE.MeshPhongMaterial({ color: COLORS.teeth });
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 1) {
                    // Dente esquerdo (encaixa na lateral esquerda)
                    const toothL = new THREE.Mesh(new THREE.BoxGeometry(T, TOOTH*0.85, T*1.5), toothMat);
                    toothL.position.set(T/2, T + TOOTH/2 + i * TOOTH, T);
                    group.add(toothL);
                    
                    // Dente direito (encaixa na lateral direita)
                    const toothR = new THREE.Mesh(new THREE.BoxGeometry(T, TOOTH*0.85, T*1.5), toothMat);
                    toothR.position.set(T/2, T + TOOTH/2 + i * TOOTH, S - T);
                    group.add(toothR);
                }
            }
            
            // Furo 70mm de entrada
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
            const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, T*3, 32), holeMat);
            hole.rotation.z = Math.PI/2;
            hole.position.set(T/2, T + S/2, S/2);
            group.add(hole);
            
            // Anel verde indicador (entrada)
            const ringMat = new THREE.MeshPhongMaterial({ color: 0x27ae60 });
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.36, 0.015, 8, 32), ringMat);
            ring.rotation.y = Math.PI/2;
            ring.position.set(-0.01, T + S/2, S/2);
            group.add(ring);
            
            // Marca√ß√£o interna - "FRONTAL" (lado de dentro da caixa)
            const label = createLabel('FRONTAL', 0.1);
            label.rotation.y = Math.PI/2; // Texto voltado para dentro
            label.position.set(T + 0.02, T + S - 0.3, S/2);
            group.add(label);
            
            // Indicador de entrada
            const labelEntrada = createLabel('ENTRADA', 0.08);
            labelEntrada.rotation.y = -Math.PI/2; // Texto voltado para fora
            labelEntrada.position.set(-0.02, T + S - 0.3, S/2);
            group.add(labelEntrada);
            
            return group;
        }
        
        function createTraseira() {
            const group = new THREE.Group();
            const W = S - 2*T; // 244mm
            
            const mat = new THREE.MeshPhongMaterial({ color: COLORS.mdf, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            // Traseira fica em X=S-T/2, altura S, largura W (entre as laterais)
            const plate = new THREE.Mesh(new THREE.BoxGeometry(T, S, W), mat);
            plate.position.set(S - T/2, T + S/2, S/2);
            group.add(plate);
            
            const toothMat = new THREE.MeshPhongMaterial({ color: COLORS.teeth });
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 1) {
                    // Dente esquerdo
                    const toothL = new THREE.Mesh(new THREE.BoxGeometry(T, TOOTH*0.85, T*1.5), toothMat);
                    toothL.position.set(S - T/2, T + TOOTH/2 + i * TOOTH, T);
                    group.add(toothL);
                    
                    // Dente direito
                    const toothR = new THREE.Mesh(new THREE.BoxGeometry(T, TOOTH*0.85, T*1.5), toothMat);
                    toothR.position.set(S - T/2, T + TOOTH/2 + i * TOOTH, S - T);
                    group.add(toothR);
                }
            }
            
            // Furo 150mm de sa√≠da
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
            const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.75, 0.75, T*3, 32), holeMat);
            hole.rotation.z = Math.PI/2;
            hole.position.set(S - T/2, T + S/2, S/2);
            group.add(hole);
            
            // Anel vermelho indicador (sa√≠da)
            const ringMat = new THREE.MeshPhongMaterial({ color: 0xe74c3c });
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.76, 0.02, 8, 32), ringMat);
            ring.rotation.y = Math.PI/2;
            ring.position.set(S + 0.01, T + S/2, S/2);
            group.add(ring);
            
            // Marca√ß√£o interna - "TRASEIRA" (lado de dentro da caixa)
            const label = createLabel('TRASEIRA', 0.1);
            label.rotation.y = -Math.PI/2; // Texto voltado para dentro
            label.position.set(S - T - 0.02, T + S - 0.3, S/2);
            group.add(label);
            
            // Indicador de sa√≠da
            const labelSaida = createLabel('SA√çDA', 0.08);
            labelSaida.rotation.y = Math.PI/2; // Texto voltado para fora
            labelSaida.position.set(S + 0.02, T + S - 0.3, S/2);
            group.add(labelSaida);
            
            return group;
        }
        
        function createDivisoria(posX, type) {
            const group = new THREE.Group();
            const W = S - 2*T; // 244mm (cabe entre as laterais)
            
            const mat = new THREE.MeshPhongMaterial({ color: COLORS.mdfLight, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
            const plate = new THREE.Mesh(new THREE.BoxGeometry(T, W, W), mat);
            plate.position.set(posX, T + S/2, S/2);
            group.add(plate);
            
            // ABAS (laranja) - passam pelos slots das laterais
            const abaMat = new THREE.MeshPhongMaterial({ color: COLORS.abas });
            [
                [T + 0.35, T/2 - 0.025],      // Inferior esquerda
                [T + S - 0.35, T/2 - 0.025],  // Superior esquerda
                [T + 0.35, S - T/2 + 0.025],  // Inferior direita
                [T + S - 0.35, S - T/2 + 0.025] // Superior direita
            ].forEach(([y, z]) => {
                const aba = new THREE.Mesh(new THREE.BoxGeometry(T*1.2, 0.38, 0.05), abaMat);
                aba.position.set(posX, y, z);
                group.add(aba);
            });
            
            // Furo do filtro com ESPESSURA CORRETA
            let fW, fH, fDepth, fColor, filterLabel;
            if (type === 'mantag3') {
                fW = 2.0; fH = 2.0; fDepth = 0.10; fColor = 0x1abc9c; filterLabel = 'Manta G3 10mm';
            } else if (type === 'gm') {
                fW = 2.23; fH = 2.1; fDepth = 0.20; fColor = 0xf1c40f; filterLabel = 'GM Bosch 20mm';
            } else if (type === 'wega') {
                fW = 2.2; fH = 1.6; fDepth = 0.45; fColor = 0x2ecc71; filterLabel = 'Wega 45mm';
            } else {
                fW = 1.1; fH = 1.4; fDepth = 0.25; fColor = 0x3498db; filterLabel = 'HEPA 25mm';
            }
            
            const filterMat = new THREE.MeshPhongMaterial({ color: fColor, transparent: true, opacity: 0.5 });
            const filter = new THREE.Mesh(new THREE.BoxGeometry(fDepth, fH, fW), filterMat);
            filter.position.set(posX + fDepth/2, T + S/2, S/2);
            group.add(filter);
            
            // Borda do filtro para destacar espessura
            const edgeMat = new THREE.MeshPhongMaterial({ color: fColor, transparent: true, opacity: 0.8 });
            const edgeGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(fDepth, fH, fW));
            const edges = new THREE.LineSegments(edgeGeom, new THREE.LineBasicMaterial({ color: fColor }));
            edges.position.set(posX + fDepth/2, T + S/2, S/2);
            group.add(edges);
            
            // Marca√ß√£o interna - identifica√ß√£o da divis√≥ria
            let labelText;
            if (type === 'mantag3') labelText = 'MANTA G3';
            else if (type === 'gm') labelText = 'GM BOSCH';
            else if (type === 'wega') labelText = 'WEGA';
            else labelText = 'FILTRO HEPA';
            
            const divLabel = createLabel(labelText, 0.1);
            divLabel.rotation.y = Math.PI/2; // Texto voltado para entrada
            divLabel.position.set(posX - 0.02, T + S - 0.25, S/2);
            group.add(divLabel);
            
            return group;
        }
        
        function createTampa() {
            const group = new THREE.Group();
            
            const mat = new THREE.MeshPhongMaterial({ color: COLORS.mdf, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            // Tampa fica no topo: base(T) + laterais(S) = T + S
            const tampa = new THREE.Mesh(new THREE.BoxGeometry(S, T, S), mat);
            tampa.position.set(S/2, T + S + T/2, S/2);
            group.add(tampa);
            
            // ========================================
            // SNAP-FIT CLIPS (substituem parafusos)
            // 8 clips no topo: 2 por lateral + 2 por frontal/traseira
            // Impressos em PLA/PETG (SNAP_TAMPA.scad)
            // Perna externa 30mm, interna 24mm, gancho 1.2mm
            // ========================================
            const clipMat = new THREE.MeshPhongMaterial({ color: 0x00bcd4, transparent: true, opacity: 0.9 });
            const slotMat2 = new THREE.MeshPhongMaterial({ color: 0x00838f });
            
            // Posi√ß√µes dos clips no topo (escala: 1u = 100mm)
            // Laterais: X=1.05 e X=1.45 (centro dos pain√©is), Z=T/2 e Z=S-T/2
            // Frontal/Traseira: Z=0.82 e Z=1.62, X=T/2 e X=S-T/2
            const clipPositions = [
                // Sobre lateral esquerda
                {x: 1.05, z: T*0.5, rotY: 0},
                {x: 1.45, z: T*0.5, rotY: 0},
                // Sobre lateral direita
                {x: 1.05, z: S - T*0.5, rotY: Math.PI},
                {x: 1.45, z: S - T*0.5, rotY: Math.PI},
                // Sobre frontal
                {x: T*0.5, z: 0.82, rotY: Math.PI/2},
                {x: T*0.5, z: 1.62, rotY: Math.PI/2},
                // Sobre traseira
                {x: S - T*0.5, z: 0.82, rotY: -Math.PI/2},
                {x: S - T*0.5, z: 1.62, rotY: -Math.PI/2}
            ];
            
            clipPositions.forEach(({x, z, rotY}) => {
                // Clip body (perna externa vis√≠vel)
                const clipGroup = new THREE.Group();
                
                // Perna vertical (30mm = 0.30)
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.30, 0.20), clipMat);
                leg.position.set(0, -0.15, 0);
                clipGroup.add(leg);
                
                // Gancho na ponta (1.2mm protrusion)
                const hook = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.04, 0.20), new THREE.MeshPhongMaterial({ color: 0xff5722 }));
                hook.position.set(-0.012, -0.30, 0);
                clipGroup.add(hook);
                
                // Topo (apoio sobre tampa)
                const top = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.02, 0.20), clipMat);
                top.position.set(0.02, 0.01, 0);
                clipGroup.add(top);
                
                clipGroup.rotation.y = rotY;
                clipGroup.position.set(x, T + S + T, z);
                group.add(clipGroup);
            });
            
            // Marca√ß√£o interna - "TAMPA" no lado de baixo (lado interno)
            const label = createLabel('TAMPA', 0.15);
            label.rotation.x = Math.PI/2;
            label.position.set(S/2, T + S - 0.01, S/2);
            group.add(label);
            
            return group;
        }
        
        function createCarbonCompartment() {
            const group = new THREE.Group();
            const W = S - 2*T; // 244mm (entre as laterais)
            
            // Posi√ß√µes das 2 telas de carv√£o (slots nas laterais)
            const telaPositions = [1.65, 2.10]; // X=165mm e X=210mm
            
            const plateMat = new THREE.MeshPhongMaterial({ color: COLORS.mdfLight, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
            const abaMat = new THREE.MeshPhongMaterial({ color: COLORS.abas });
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
            const meshMat = new THREE.MeshPhongMaterial({ color: 0x888888, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            
            telaPositions.forEach((posX) => {
                // Placa MDF 244√ó244mm
                const plate = new THREE.Mesh(new THREE.BoxGeometry(T, W, W), plateMat);
                plate.position.set(posX, T + S/2, S/2);
                group.add(plate);
                
                // 4 Abas para encaixe nos slots das laterais
                [
                    [T + 0.35, T/2 - 0.025],      // Inferior esquerda
                    [T + S - 0.35, T/2 - 0.025],  // Superior esquerda
                    [T + 0.35, S - T/2 + 0.025],  // Inferior direita
                    [T + S - 0.35, S - T/2 + 0.025] // Superior direita
                ].forEach(([y, z]) => {
                    const aba = new THREE.Mesh(new THREE.BoxGeometry(T*1.2, 0.38, 0.05), abaMat);
                    aba.position.set(posX, y, z);
                    group.add(aba);
                });
                
                // Abertura central 200√ó200mm (furo √∫nico)
                const openSize = 2.0; // 200mm
                const openHole = new THREE.Mesh(new THREE.BoxGeometry(T*2, openSize, openSize), holeMat);
                openHole.position.set(posX, T + S/2, S/2);
                group.add(openHole);
                
                // Tela alum√≠nio mosquiteira sobre a abertura (transl√∫cida)
                const meshScreen = new THREE.Mesh(new THREE.PlaneGeometry(openSize, openSize), meshMat);
                meshScreen.rotation.y = Math.PI/2;
                meshScreen.position.set(posX + T*0.6, T + S/2, S/2);
                group.add(meshScreen);
                
                // 16 Furos M3+arruela ao redor da abertura (4 por lado)
                const screwMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
                const screwR = 0.02; // 2mm visual radius
                // Posi√ß√µes dos furos (escala: 1u = 100mm)
                // Esq X=14‚Üí0.14, Dir X=230‚Üí2.30, Inf Y=11‚Üí0.11, Sup Y=233‚Üí2.33
                // Furos ao longo: Y/Z = 0.62, 1.02, 1.42, 1.82
                const holePositions = [
                    // Coluna esquerda (Z=0.14+T)
                    {y: 0.62, z: 0.14+T}, {y: 1.02, z: 0.14+T}, {y: 1.42, z: 0.14+T}, {y: 1.82, z: 0.14+T},
                    // Coluna direita (Z=2.30+T)
                    {y: 0.62, z: 2.30+T}, {y: 1.02, z: 2.30+T}, {y: 1.42, z: 2.30+T}, {y: 1.82, z: 2.30+T},
                    // Fileira inferior (Y=0.11+T)
                    {y: 0.11+T, z: 0.62+T}, {y: 0.11+T, z: 1.02+T}, {y: 0.11+T, z: 1.42+T}, {y: 0.11+T, z: 1.82+T},
                    // Fileira superior (Y=2.33+T)
                    {y: 2.33+T, z: 0.62+T}, {y: 2.33+T, z: 1.02+T}, {y: 2.33+T, z: 1.42+T}, {y: 2.33+T, z: 1.82+T}
                ];
                holePositions.forEach(({y, z}) => {
                    const screw = new THREE.Mesh(new THREE.CylinderGeometry(screwR, screwR, T*3, 8), screwMat);
                    screw.rotation.z = Math.PI/2;
                    screw.position.set(posX, y, z);
                    group.add(screw);
                });
                
                // Borda da placa para destaque
                const edgeGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(T, W, W));
                const edges = new THREE.LineSegments(edgeGeom, new THREE.LineBasicMaterial({ color: 0x666666 }));
                edges.position.set(posX, T + S/2, S/2);
                group.add(edges);
            });
            
            // Volume de carv√£o ativado entre as 2 telas
            const carvaoMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, transparent: true, opacity: 0.7 });
            const carbonDepth = telaPositions[1] - telaPositions[0]; // 0.35 (35mm)
            const carbonCenter = (telaPositions[0] + telaPositions[1]) / 2;
            const carvao = new THREE.Mesh(new THREE.BoxGeometry(carbonDepth - T*2, W * 0.85, W * 0.85), carvaoMat);
            carvao.position.set(carbonCenter, T + S/2, S/2);
            group.add(carvao);
            
            // ========================================
            // CAIXA DE CARV√ÉO - 4 tiras MDF com encaixe
            // 4 strips formando ret√¢ngulo 244√ó244√ó42mm
            // ========================================
            const stripMat = new THREE.MeshPhongMaterial({ color: 0xA0522D, transparent: true, opacity: 0.85 });
            const stripDepth = carbonDepth; // 42mm = 0.42 (dist√¢ncia entre telas)
            const stripThick = T; // 3mm MDF
            
            // Tiras verticais (esquerda e direita) - 244mm √ó 42mm
            const vertStrip = new THREE.BoxGeometry(stripDepth, W, stripThick);
            const stripLeft = new THREE.Mesh(vertStrip, stripMat);
            stripLeft.position.set(carbonCenter, T + S/2, T + stripThick/2);
            group.add(stripLeft);
            
            const stripRight = new THREE.Mesh(vertStrip.clone(), stripMat);
            stripRight.position.set(carbonCenter, T + S/2, S - T - stripThick/2);
            group.add(stripRight);
            
            // Tiras horizontais (superior e inferior) - 238mm corpo √ó 42mm
            const horizW = W - 2*T; // 238mm (entre as verticais)
            const horizStrip = new THREE.BoxGeometry(stripDepth, stripThick, horizW);
            const stripTop = new THREE.Mesh(horizStrip, stripMat);
            stripTop.position.set(carbonCenter, T + S - stripThick/2, S/2);
            group.add(stripTop);
            
            const stripBottom = new THREE.Mesh(horizStrip.clone(), stripMat);
            stripBottom.position.set(carbonCenter, T + stripThick/2, S/2);
            group.add(stripBottom);
            
            // Indicadores de encaixe (tab/slot nos cantos - amarelo)
            const tabMat = new THREE.MeshPhongMaterial({ color: 0xf1c40f, transparent: true, opacity: 0.9 });
            const tabSize = new THREE.BoxGeometry(stripDepth * 0.15, stripThick * 0.8, stripThick * 1.2);
            // 4 cantos √ó 2 tabs = 8 indicadores
            [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(([vy, vz]) => {
                const tabY = T + S/2 + vy * (W/2 - stripThick/2);
                const tabZ = S/2 + vz * (W/2 - stripThick/2);
                [0.08, 0.24].forEach(frac => {
                    const tab = new THREE.Mesh(tabSize, tabMat);
                    tab.position.set(carbonCenter - stripDepth/2 + stripDepth * frac, tabY, tabZ);
                    group.add(tab);
                });
            });
            
            // Borda do volume de carv√£o
            const carbonEdges = new THREE.LineSegments(
                new THREE.EdgesGeometry(new THREE.BoxGeometry(carbonDepth, W, W)),
                new THREE.LineBasicMaterial({ color: 0x555555 })
            );
            carbonEdges.position.set(carbonCenter, T + S/2, S/2);
            group.add(carbonEdges);
            
            // Labels
            const label = createLabel('CARV√ÉO', 0.1);
            label.rotation.y = Math.PI/2;
            label.position.set(carbonCenter, T + S - 0.25, S/2);
            group.add(label);
            
            const labelT1 = createLabel('TELA 1', 0.06);
            labelT1.rotation.y = Math.PI/2;
            labelT1.position.set(telaPositions[0] - 0.05, T + 0.3, S/2);
            group.add(labelT1);
            
            const labelT2 = createLabel('TELA 2', 0.06);
            labelT2.rotation.y = Math.PI/2;
            labelT2.position.set(telaPositions[1] + 0.05, T + 0.3, S/2);
            group.add(labelT2);
            
            return group;
        }
        
        function updateStep() {
            const step = steps[currentStep];
            
            document.getElementById('stepNum').textContent = step.num;
            document.getElementById('stepTitle').textContent = step.title;
            document.getElementById('stepDesc').textContent = step.desc;
            document.getElementById('progressFill').style.width = ((currentStep + 1) / steps.length * 100) + '%';
            
            const encaixeInfo = document.getElementById('encaixeInfo');
            encaixeInfo.className = 'encaixe-info ' + step.type;
            document.getElementById('encaixeDesc').textContent = step.encaixe;
            
            document.getElementById('btnPrev').classList.toggle('btn-disabled', currentStep === 0);
            document.getElementById('btnNext').textContent = currentStep === steps.length - 1 ? '‚úì Completo' : 'Pr√≥ximo ‚Üí';
            
            Object.keys(parts).forEach(key => {
                parts[key].visible = step.parts.includes(key);
            });
            
            animateCamera(step.camera.pos, step.camera.look);
        }
        
        function animateCamera(pos, look) {
            const startPos = camera.position.clone();
            const endPos = new THREE.Vector3(...pos);
            const endLook = new THREE.Vector3(...look);
            const duration = 500;
            const startTime = Date.now();
            
            function update() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3);
                
                camera.position.lerpVectors(startPos, endPos, eased);
                camera.lookAt(endLook);
                
                if (t < 1) requestAnimationFrame(update);
            }
            update();
        }
        
        function nextStep() {
            if (currentStep < steps.length - 1) { currentStep++; updateStep(); }
        }
        
        function prevStep() {
            if (currentStep > 0) { currentStep--; updateStep(); }
        }
        
        function resetView() {
            const step = steps[currentStep];
            animateCamera(step.camera.pos, step.camera.look);
        }
        
        function viewFront() { animateCamera([-3, 1.5, 1.25], [1.25, 1.3, 1.25]); }
        function viewBack() { animateCamera([5.5, 1.5, 1.25], [1.25, 1.3, 1.25]); }
        function viewSide() { animateCamera([1.25, 1.5, -2.5], [1.25, 1.3, 1.25]); }
        function viewTop() { animateCamera([1.25, 6, 1.25], [1.25, 0.5, 1.25]); }
        function viewInside() { animateCamera([1.25, 1.3, 1.25], [1.25, 1.3, 2.5]); }
        
        function toggleExplode() {
            explodeMode = document.getElementById('chkExplode').checked;
            updateExplosion();
        }
        
        function updateExplosion() {
            const offset = explodeMode ? 0.4 : 0;
            if (parts.base) parts.base.position.y = -offset;
            if (parts.tampa) parts.tampa.position.y = offset;
            if (parts.latEsq) parts.latEsq.position.z = -offset;
            if (parts.latDir) parts.latDir.position.z = offset;
            if (parts.frontal) parts.frontal.position.x = -offset;
            if (parts.traseira) parts.traseira.position.x = offset;
            if (parts.divMantaG3) parts.divMantaG3.position.y = offset * 0.4;
            if (parts.divGM) parts.divGM.position.y = offset * 0.3;
            if (parts.divWega) parts.divWega.position.y = offset * 0.2;
            if (parts.divHepa) parts.divHepa.position.y = offset * 0.1;
            if (parts.gaveta) parts.gaveta.position.x = offset * 0.3;
        }
        
        function toggleWireframe() {
            wireframeMode = document.getElementById('chkWireframe').checked;
            Object.values(parts).forEach(group => {
                group.traverse(child => {
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.wireframe = wireframeMode);
                        } else {
                            child.material.wireframe = wireframeMode;
                        }
                    }
                });
            });
        }
        
        function toggleAutoRotate() {
            autoRotate = document.getElementById('chkAutoRotate').checked;
        }
        
        function viewDetail() {
            if (currentStep === 3 || currentStep === 4) {
                animateCamera([0.15, 1.5, 0.8], [0.05, 1.3, 0.3]);
            } else if (currentStep === 5) {
                animateCamera([0.6, 1.2, 0.2], [0.4, 0.8, 0.1]);
            } else if (currentStep === 6) {
                animateCamera([2.5, 0.6, 0.5], [2.1, 0.25, 1.25]);
            } else {
                animateCamera([2.5, 1.8, 2.5], [1.25, 1.3, 1.25]);
            }
        }
        
        function setupMouse() {
            let dragging = false;
            let prevX = 0, prevY = 0;
            let shiftKey = false;
            
            renderer.domElement.onmousedown = e => { 
                dragging = true; 
                prevX = e.clientX; 
                prevY = e.clientY; 
                shiftKey = e.shiftKey;
            };
            
            renderer.domElement.onmousemove = e => {
                if (!dragging) return;
                const dx = e.clientX - prevX;
                const dy = e.clientY - prevY;
                
                if (e.shiftKey || shiftKey) {
                    // Pan (mover c√¢mera lateralmente)
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.getWorldDirection(up);
                    right.crossVectors(up, camera.up).normalize();
                    up.crossVectors(right, camera.getWorldDirection(new THREE.Vector3())).normalize();
                    
                    camera.position.addScaledVector(right, -dx * 0.005);
                    camera.position.addScaledVector(up, dy * 0.005);
                } else {
                    // Rota√ß√£o orbital
                    const pivot = new THREE.Vector3(1.25, 1.3, 1.25);
                    camera.position.sub(pivot);
                    const spherical = new THREE.Spherical().setFromVector3(camera.position);
                    spherical.theta -= dx * 0.005;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi - dy * 0.005));
                    camera.position.setFromSpherical(spherical).add(pivot);
                    camera.lookAt(pivot);
                }
                
                prevX = e.clientX; prevY = e.clientY;
            };
            
            renderer.domElement.onmouseup = () => { dragging = false; shiftKey = false; };
            renderer.domElement.onmouseleave = () => { dragging = false; shiftKey = false; };
            
            renderer.domElement.onwheel = e => {
                e.preventDefault();
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const zoomSpeed = e.deltaY * 0.003;
                camera.position.addScaledVector(dir, -zoomSpeed);
            };
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rota√ß√£o
            if (autoRotate) {
                const pivot = new THREE.Vector3(1.25, 1.3, 1.25);
                camera.position.sub(pivot);
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta += 0.003;
                camera.position.setFromSpherical(spherical).add(pivot);
                camera.lookAt(pivot);
            }
            
            renderer.render(scene, camera);
        }
        
        document.onkeydown = e => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextStep();
            if (e.key === 'ArrowLeft') prevStep();
            if (e.key === 'd' || e.key === 'D') viewDetail();
        };
    </script>
</body>
</html>
