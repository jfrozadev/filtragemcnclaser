<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Animação — Montagem Clip Wega na Divisória MDF</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
canvas { display: block; }
#ui {
  position: absolute; top: 0; left: 0; right: 0;
  display: flex; justify-content: space-between; align-items: flex-start;
  padding: 12px 16px; pointer-events: none;
}
#info {
  background: rgba(0,0,0,0.8); border-radius: 8px; padding: 14px 18px;
  max-width: 420px; pointer-events: auto;
}
#info h2 { font-size: 15px; color: #ffa500; margin-bottom: 6px; }
#info .step { font-size: 13px; line-height: 1.6; color: #ccc; }
#info .step b { color: #fff; }
#info .dim { font-size: 11px; color: #888; margin-top: 8px; }
#controls {
  background: rgba(0,0,0,0.8); border-radius: 8px; padding: 10px 14px;
  pointer-events: auto; text-align: center;
}
#controls button {
  background: #ffa500; color: #000; border: none; border-radius: 4px;
  padding: 6px 14px; margin: 2px 4px; cursor: pointer; font-size: 13px; font-weight: 600;
}
#controls button:hover { background: #ffb733; }
#controls button.active { background: #ff6600; color: #fff; }
#controls .label { font-size: 11px; color: #888; margin-top: 6px; }
#legend {
  position: absolute; bottom: 12px; left: 16px;
  background: rgba(0,0,0,0.7); border-radius: 6px; padding: 8px 14px;
  font-size: 11px; line-height: 1.8;
}
.leg-item { display: flex; align-items: center; gap: 6px; }
.leg-box { width: 14px; height: 10px; border-radius: 2px; display: inline-block; }
#section {
  position: absolute; bottom: 12px; right: 16px;
  background: rgba(0,0,0,0.8); border-radius: 6px; padding: 10px 14px;
  font-size: 11px; line-height: 1.2; white-space: pre; font-family: 'Consolas', monospace;
  color: #aaa;
}
</style>
</head>
<body>

<div id="ui">
  <div id="info">
    <h2 id="stepTitle">Passo 1/4 — Clip afastado</h2>
    <div class="step" id="stepDesc"></div>
    <div class="dim">
      Clip: 30mm larg · Lip 3mm · Parede 2mm · Aba 11.5mm<br>
      MDF: 3mm · Frame: 9.5×4mm · Furo: 220×164mm (SEM slots)
    </div>
  </div>
  <div id="controls">
    <button onclick="prevStep()">◀ Anterior</button>
    <button id="btnPlay" onclick="togglePlay()">▶ Play</button>
    <button onclick="nextStep()">Próximo ▶</button>
    <div class="label">Arraste = girar · Scroll = zoom</div>
  </div>
</div>

<div id="legend">
  <div class="leg-item"><span class="leg-box" style="background:#ff8c00"></span> Clip (PLA/PETG)</div>
  <div class="leg-item"><span class="leg-box" style="background:#deb887"></span> MDF 3mm</div>
  <div class="leg-item"><span class="leg-box" style="background:#32cd32"></span> Frame filtro 4mm</div>
  <div class="leg-item"><span class="leg-box" style="background:#2f4f4f"></span> Corpo filtro 45mm</div>
</div>

<div id="section">
CORTE LATERAL (SCAD coords):

      aba 1.5mm
 ┌───────────────────┐
 │    (sobre frame)  │ batente
 │                   │┌─┐ 2.5mm
 │ parede   FRAME    ││ │
 │  2mm    4mm       ││ │
 │         (verde)   │└─┘
 │═══ MDF 3mm ═══════╡
 └─lip─┘  (furo)
   3mm
 ← furo    borda   sólido →
 Y&lt;0       Y=0      Y&gt;0
</div>

<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ============================================================
// SCAD coords: X=largura, Y=profundidade(0=borda furo), Z=altura
// Three.js:    X=largura, Y=altura(up),  Z=profundidade
//
// Mapeamento: SCAD_X → X, SCAD_Z → Y, SCAD_Y → -Z
// Então:  furo está em +Z (para o viewer), sólido MDF em -Z
// ============================================================

// === PARÂMETROS (idênticos ao CLIP_WEGA.scad) ===
const MDF = 3;
const CLIP_LARG = 30, CLIP_PAREDE = 2;
const LIP_PROF = 3, LIP_ESP = 2;
const ABA_COMP = 11.5, ABA_ESP = 1.5;
const BATENTE_ALT = 2.5;
const BORDA_ESP = 4, BORDA_LARG = 9.5;
const FOLGA = 0.5;
const GAP = LIP_ESP + MDF + BORDA_ESP + FOLGA; // 9.5

// Seção visível do MDF e furo
const MDF_SOLID = 16; // extensão visível do MDF sólido (para -Z)
const MDF_HOLE = 12;  // extensão visível do furo (para +Z)
const MDF_SIDE = 8;   // extensão lateral para cada lado em X

// === SCENE ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

const camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 500);
camera.position.set(35, 20, 30);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const ctrl = new OrbitControls(camera, renderer.domElement);
ctrl.target.set(0, 8, -2);
ctrl.enableDamping = true;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.45));
const dl = new THREE.DirectionalLight(0xffffff, 1.0);
dl.position.set(30, 40, 25); dl.castShadow = true;
scene.add(dl);
const dl2 = new THREE.DirectionalLight(0xffffff, 0.3);
dl2.position.set(-20, 10, -15);
scene.add(dl2);

// === MATERIALS ===
const matMDF    = new THREE.MeshStandardMaterial({ color: 0xdeb887, transparent: true, opacity: 0.65 });
const matClip   = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
const matFrame  = new THREE.MeshStandardMaterial({ color: 0x32cd32, transparent: true, opacity: 0.45 });
const matCorpo  = new THREE.MeshStandardMaterial({ color: 0x2f4f4f, transparent: true, opacity: 0.3 });

function box(w, h, d) { return new THREE.BoxGeometry(w, h, d); }
function mesh(geo, mat) {
  const m = new THREE.Mesh(geo, mat);
  m.castShadow = true; m.receiveShadow = true;
  return m;
}

// ============================================================
// Coordenadas Three.js finais de cada peça SCAD montada:
//
// SCAD cube([W,D,H]) at translate([tx,ty,tz])
//   → Three.js: centro em (tx+W/2, tz+H/2, -(ty+D/2))
//              tamanho  (W, H, D)
//
// Y=0 no SCAD (borda do furo) = Z=0 no Three.js
// base_esp no SCAD = Y=base_esp no Three.js
// ============================================================

// === MDF PLACA (secção com furo, SEM slots) ===
const mdfGroup = new THREE.Group();

// Placa sólida: Z=0 a Z=-MDF_SOLID, Y=LIP_ESP a Y=LIP_ESP+MDF
const mdfSolid = mesh(box(CLIP_LARG + 2*MDF_SIDE, MDF, MDF_SOLID), matMDF);
mdfSolid.position.set(0, LIP_ESP + MDF/2, -MDF_SOLID/2);
mdfGroup.add(mdfSolid);

// Borda furo lado esq/dir: de Z=0 a Z=+MDF_HOLE
const mdfHoleL = mesh(box(MDF_SIDE, MDF, MDF_HOLE), matMDF);
mdfHoleL.position.set(-(CLIP_LARG/2 + MDF_SIDE/2), LIP_ESP + MDF/2, MDF_HOLE/2);
mdfGroup.add(mdfHoleL);
const mdfHoleR = mesh(box(MDF_SIDE, MDF, MDF_HOLE), matMDF);
mdfHoleR.position.set(CLIP_LARG/2 + MDF_SIDE/2, LIP_ESP + MDF/2, MDF_HOLE/2);
mdfGroup.add(mdfHoleR);

scene.add(mdfGroup);

// === CLIP (grupo animável) ===
const clipGroup = new THREE.Group();

// Lip: cube([30, 3, 2]) at (0,0,0)
// Three.js: centro (0, LIP_ESP/2, -(LIP_PROF/2))
const clipLip = mesh(box(CLIP_LARG, LIP_ESP, LIP_PROF), matClip);
clipLip.position.set(0, LIP_ESP/2, -(LIP_PROF/2));
clipGroup.add(clipLip);

// Parede: cube([30, 2, GAP+ABA_ESP]) at (0, -2, 0)
// Three.js: centro (0, (GAP+ABA_ESP)/2, CLIP_PAREDE/2)
const clipParede = mesh(box(CLIP_LARG, GAP + ABA_ESP, CLIP_PAREDE), matClip);
clipParede.position.set(0, (GAP + ABA_ESP)/2, CLIP_PAREDE/2);
clipGroup.add(clipParede);

// Aba: cube([30, 13.5, 1.5]) at (0, -2, GAP)
const clipAba = mesh(box(CLIP_LARG, ABA_ESP, ABA_COMP + CLIP_PAREDE), matClip);
clipAba.position.set(0, GAP + ABA_ESP/2, -((ABA_COMP + CLIP_PAREDE)/2 - CLIP_PAREDE));
clipGroup.add(clipAba);

// Batente
const batW = ABA_COMP - BORDA_LARG; // 2mm
const clipBatente = mesh(box(CLIP_LARG, BATENTE_ALT + ABA_ESP, batW), matClip);
clipBatente.position.set(0, GAP - BATENTE_ALT/2 + ABA_ESP/2, -(BORDA_LARG + batW/2));
clipGroup.add(clipBatente);

scene.add(clipGroup);

// === FRAME DO FILTRO ===
const frameGroup = new THREE.Group();

// Frame: repousa sobre MDF, Y_scad=0..BORDA_LARG, Z_scad=LIP_ESP+MDF..LIP_ESP+MDF+BORDA_ESP
const frame = mesh(box(CLIP_LARG + 2*MDF_SIDE, BORDA_ESP, BORDA_LARG), matFrame);
frame.position.set(0, LIP_ESP + MDF + BORDA_ESP/2, -(BORDA_LARG/2));
frameGroup.add(frame);

// Corpo do filtro (parcial, passa pelo furo, desce abaixo do MDF)
const corpoPart = 30;
const corpo = mesh(box(CLIP_LARG - 4, corpoPart, MDF_HOLE - 2), matCorpo);
corpo.position.set(0, LIP_ESP + MDF + BORDA_ESP - corpoPart/2, (MDF_HOLE-2)/2 - BORDA_LARG + 2);
frameGroup.add(corpo);

scene.add(frameGroup);

// === GRID (chão de referência) ===
const gridHelper = new THREE.GridHelper(80, 20, 0x333355, 0x222244);
gridHelper.position.y = -0.5;
scene.add(gridHelper);

// === EIXOS de referência ===
const axLen = 5;
scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(-22,0,0), axLen, 0x4488ff));
scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), new THREE.Vector3(-22,0,0), axLen, 0xff4444));

// Labels
function makeLabel(text, pos, color='#fff', size=12) {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 64;
  const ctx = c.getContext('2d');
  ctx.font = `bold ${size*2}px Segoe UI`;
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.fillText(text, 256, 44);
  const tex = new THREE.CanvasTexture(c);
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
  sp.scale.set(14, 3.5, 1);
  sp.position.copy(pos);
  scene.add(sp);
  return sp;
}

makeLabel('← FURO', new THREE.Vector3(-22, 1, 6), '#4488ff');
makeLabel('MDF SÓLIDO →', new THREE.Vector3(-22, 1, -6), '#ff6644');
makeLabel('Borda do furo (Y=0)', new THREE.Vector3(0, -1.5, 0.5), '#888');

// ============ PASSOS DA ANIMAÇÃO ============
const steps = [
  {
    title: "Passo 1/4 — Clip separado",
    desc: "O clip está acima da divisória MDF.<br><b>Parede</b> (laranja, 2mm) ficará do lado do <b>furo</b> (azul).<br><b>Lip</b> (3mm) enganchará sob o MDF na borda do furo.<br>Clips SÓ nos lados Y — lados X são para <b>trilhos</b>.",
    clip:  { x:0, y:25, z:12 },
    clipR: { x:-0.3, y:0, z:0 },
    frame: { x:0, y:50, z:0 },
  },
  {
    title: "Passo 2/4 — Incline e encaixe o lip",
    desc: "Incline o clip e encaixe o <b>lip</b> sob a borda do MDF.<br>O lip engancha por baixo (3mm sob o MDF sólido).<br>A <b>parede</b> fica na abertura do furo — não colide com nada.",
    clip:  { x:0, y:5, z:5 },
    clipR: { x:-0.15, y:0, z:0 },
    frame: { x:0, y:50, z:0 },
  },
  {
    title: "Passo 3/4 — Clip encaixado!",
    desc: "Pressione a aba para baixo. O <b>lip</b> engancha sob o MDF.<br>✅ O clip está fixo! SEM furos extras no MDF.<br>SEM dentes, SEM slots. Instalação 100% pela face do frame.",
    clip:  { x:0, y:0, z:0 },
    clipR: { x:0, y:0, z:0 },
    frame: { x:0, y:50, z:0 },
  },
  {
    title: "Passo 4/4 — Filtro encaixa (desliza pelos trilhos)",
    desc: "Deslize o filtro pelos <b>trilhos</b> (lados X). O <b>corpo</b> passa pelo furo e o <b>frame</b> (verde) repousa sobre o MDF.<br>Frame preso: lip + aba + batente + MDF.",
    clip:  { x:0, y:0, z:0 },
    clipR: { x:0, y:0, z:0 },
    frame: { x:0, y:0, z:0 },
  },
];

let cur = 0, playing = false, animT = 0;
const DUR = 1.8;

function easeIO(t) { return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }
function lerp(a,b,t) { return a+(b-a)*Math.min(1,Math.max(0,t)); }

function setStep(i) { cur = Math.max(0,Math.min(steps.length-1,i)); animT=0; updateUI(); }
function updateUI() {
  document.getElementById('stepTitle').textContent = steps[cur].title;
  document.getElementById('stepDesc').innerHTML = steps[cur].desc;
}
window.nextStep = () => setStep(cur+1);
window.prevStep = () => setStep(cur-1);
window.togglePlay = () => {
  playing = !playing;
  document.getElementById('btnPlay').textContent = playing ? '⏸ Pause' : '▶ Play';
  if (playing && cur >= steps.length-1) setStep(0);
};

// ============ RENDER ============
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  ctrl.update();

  animT += dt / DUR;
  const t = easeIO(Math.min(1, animT));

  const s = steps[cur];
  const p = cur > 0 ? steps[cur-1] : s;

  clipGroup.position.set(lerp(p.clip.x,s.clip.x,t), lerp(p.clip.y,s.clip.y,t), lerp(p.clip.z,s.clip.z,t));
  clipGroup.rotation.set(lerp(p.clipR.x,s.clipR.x,t), lerp(p.clipR.y,s.clipR.y,t), lerp(p.clipR.z,s.clipR.z,t));
  frameGroup.position.set(lerp(p.frame.x,s.frame.x,t), lerp(p.frame.y,s.frame.y,t), lerp(p.frame.z,s.frame.z,t));

  // Pulse clip on step 3
  if (cur === 2 && t > 0.7) {
    const pulse = 0.5 + 0.5*Math.sin(Date.now()*0.006);
    matClip.emissive.setRGB(pulse*0.3, pulse*0.2, 0);
  } else {
    matClip.emissive.setRGB(0,0,0);
  }

  // Auto-play
  if (playing && animT > DUR + 0.8) {
    if (cur < steps.length-1) setStep(cur+1);
    else { playing=false; document.getElementById('btnPlay').textContent='▶ Play'; }
  }

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

updateUI();
animate();
</script>
</body>
</html>
