<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Montagem â€” Filtro HEPA + Clips Snap-fit</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',system-ui,sans-serif;background:#1a1a2e;overflow:hidden}
#c{width:100vw;height:100vh;display:block}
#panel{position:absolute;top:10px;left:10px;background:rgba(255,255,255,.97);padding:14px;border-radius:10px;max-width:320px;box-shadow:0 8px 30px rgba(0,0,0,.4);max-height:calc(100vh - 20px);overflow-y:auto}
h1{font-size:.95rem;color:#2c3e50;margin-bottom:2px}
.sub{font-size:.6rem;color:#7f8c8d;margin-bottom:8px}
.step{background:#e8f5e9;padding:10px;border-radius:8px;margin-bottom:8px;border-left:3px solid #4caf50}
.step h2{font-size:.78rem;color:#2c3e50;margin-bottom:3px}
.step p{font-size:.65rem;color:#555;line-height:1.35}
.nav{display:flex;gap:6px;margin-bottom:8px}
.nav button{flex:1;padding:7px;border:none;border-radius:6px;font-size:.72rem;font-weight:600;cursor:pointer;transition:.15s}
.bp{background:#ecf0f1;color:#2c3e50}.bp:hover{background:#d5dbdb}
.bn{background:#4caf50;color:#fff}.bn:hover{background:#388e3c}
.sec{background:#f8f9fa;border:1px solid #dee2e6;border-radius:6px;padding:8px;margin-bottom:8px}
.sec h3{font-size:.68rem;color:#495057;margin-bottom:4px}
.sec pre{font-size:.58rem;line-height:1.3;color:#333;font-family:'Cascadia Code','Consolas',monospace}
.specs{font-size:.6rem;color:#666;margin-bottom:6px}
.specs table{width:100%;border-collapse:collapse}
.specs td{padding:1px 4px}.specs .l{color:#888}.specs .v{font-weight:600;text-align:right}
.hepa{background:#e3f2fd;border:1px solid #2196f3;border-radius:4px;padding:5px;font-size:.58rem;color:#1565c0;margin-bottom:6px}
.legend{display:flex;gap:8px;flex-wrap:wrap}
.legend span{display:flex;align-items:center;gap:3px;font-size:.58rem}
.legend i{width:10px;height:10px;border-radius:2px;display:inline-block}
#info{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,.85);padding:5px 14px;border-radius:6px;font-size:.62rem;white-space:nowrap}
</style>
</head>
<body>
<div id="c"></div>
<div id="panel">
  <h1>ğŸ”§ Montagem â€” Filtro HEPA</h1>
  <div class="sub">DivisÃ³ria 244Ã—240mm Â· Furo 100Ã—130mm Â· 8 clips compactos</div>
  <div class="step"><h2 id="sT"></h2><p id="sD"></p></div>
  <div class="nav">
    <button class="bp" onclick="prev()">â† Anterior</button>
    <button class="bn" onclick="next()">PrÃ³ximo â†’</button>
  </div>
  <div class="hepa">ğŸ¥ Filtro HEPA: Alta eficiÃªncia, partÃ­culas ultrafinas. Furo menor = maior vedaÃ§Ã£o.</div>
  <div class="sec">
    <h3>SeÃ§Ã£o transversal do clip</h3>
    <pre>
       â”Œâ”€â”€â”€ aba 7mm â”€â”€â”€â”   (1.2mm)
       â”‚ HEPA 25mm     â”‚   (borda 5Ã—2mm)
  â•â•â•â•â•â•ªâ•â• MDF 3mm â•â•â•â•â•ªâ•â•â•â•â•
       â”‚   base 8mm    â”‚
       â””â”€â”¤denteâ”œâ”€â”€â”€â”¤denteâ”œâ”€â”˜
    </pre>
  </div>
  <div class="specs"><table>
    <tr><td class="l">Filtro:</td><td class="v">HEPA â€” 110Ã—140Ã—25mm</td></tr>
    <tr><td class="l">Borda:</td><td class="v">5Ã—2mm</td></tr>
    <tr><td class="l">Furo MDF:</td><td class="v">100Ã—130mm (centralizado)</td></tr>
    <tr><td class="l">Clips:</td><td class="v">8Ã— (larg 25mm, aba 7mm)</td></tr>
  </table></div>
  <div class="legend">
    <span><i style="background:#CD853F"></i>MDF</span>
    <span><i style="background:#3498db"></i>Filtro HEPA</span>
    <span><i style="background:#e67e22"></i>Clip</span>
    <span><i style="background:#c0392b"></i>Dentes</span>
    <span><i style="background:#222"></i>Slots</span>
  </div>
</div>
<div id="info">ğŸ–±ï¸ Arrastar = Girar Â· Scroll = Zoom Â· â† â†’ = Passos</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ===== DADOS DO NC E SCAD ===== */
// Escala: 1 unidade = 100mm

// MDF 244Ã—240Ã—3mm
const W = 2.44, H = 2.40, T = 0.03;

// Furo 100Ã—130mm (X: 72-172, Y: 55-185)
const HOLE_X1 = 0.72, HOLE_X2 = 1.72;
const HOLE_Z1 = 0.55, HOLE_Z2 = 1.85;
const HOLE_W = HOLE_X2 - HOLE_X1;  // 1.00
const HOLE_H = HOLE_Z2 - HOLE_Z1;  // 1.30

// Filtro HEPA 110Ã—140Ã—25mm (borda 5Ã—2mm)
const FILT_W = 1.10, FILT_H = 1.40, FILT_T = 0.25;
const BORDA_W = 0.05, BORDA_ESP = 0.02;

// Clip (CLIP_HEPA.scad)
const CLIP_LARG = 0.25;    // 25mm
const CLIP_PAREDE = 0.02;  // 2mm
const ABA_COMP = 0.07;     // 7mm (curta)
const ABA_ESP = 0.012;     // 1.2mm
const BASE_PROF = 0.08;    // 8mm
const DENTE_POS = 0.06;    // 6mm

// PosiÃ§Ãµes dos 8 clips (NC: X=105,139 e Y=100,140)
const CLIPS = [
  // Inferior (Z=0.55)
  { x: 1.05, z: HOLE_Z1, rot: Math.PI },
  { x: 1.39, z: HOLE_Z1, rot: Math.PI },
  // Superior (Z=1.85)
  { x: 1.05, z: HOLE_Z2, rot: 0 },
  { x: 1.39, z: HOLE_Z2, rot: 0 },
  // Esquerdo (X=0.72)
  { x: HOLE_X1, z: 1.00, rot: -Math.PI/2 },
  { x: HOLE_X1, z: 1.40, rot: -Math.PI/2 },
  // Direito (X=1.72)
  { x: HOLE_X2, z: 1.00, rot: Math.PI/2 },
  { x: HOLE_X2, z: 1.40, rot: Math.PI/2 }
];

// Slots
const SLOTS_H = [
  [0.99, 0.46], [1.11, 0.46], [1.33, 0.46], [1.45, 0.46],
  [0.99, 1.94], [1.11, 1.94], [1.33, 1.94], [1.45, 1.94]
];
const SLOTS_V = [
  [0.63, 0.94], [0.63, 1.06], [0.63, 1.34], [0.63, 1.46],
  [1.81, 0.94], [1.81, 1.06], [1.81, 1.34], [1.81, 1.46]
];

const STEPS = [
  { title: "Etapa 1/4 â€” DivisÃ³ria MDF",
    desc: "Placa MDF 244Ã—240Ã—3mm. Furo 100Ã—130mm centralizado para o filtro HEPA compacto.",
    show: { mdf: true, slots: true, filter: false, clips: false } },
  { title: "Etapa 2/4 â€” Posicionar Filtro HEPA",
    desc: "Coloque o filtro HEPA (110Ã—140Ã—25mm). Borda de 5Ã—2mm apoia no MDF.",
    show: { mdf: true, slots: true, filter: true, clips: false } },
  { title: "Etapa 3/4 â€” Encaixar os 8 Clips",
    desc: "Clips compactos (25mm larg, aba 7mm). Pressione atÃ© ouvir o click dos dentes.",
    show: { mdf: true, slots: true, filter: true, clips: true } },
  { title: "Etapa 4/4 â€” Montagem Completa",
    desc: "âœ… Filtro HEPA fixado! Alta vedaÃ§Ã£o para filtragem de partÃ­culas ultrafinas.",
    show: { mdf: true, slots: true, filter: true, clips: true } }
];

let step = 0;
let scene, camera, renderer;
let groups = {};
let isDragging = false, prevMouse = { x: 0, y: 0 };
let spherical = { phi: 0.8, theta: 0.6, radius: 4.5 };

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x263238);
  
  camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 0.1, 100);
  
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  document.getElementById('c').appendChild(renderer.domElement);
  
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const dl1 = new THREE.DirectionalLight(0xffffff, 0.7);
  dl1.position.set(5, 8, 6);
  scene.add(dl1);
  const dl2 = new THREE.DirectionalLight(0xffffff, 0.3);
  dl2.position.set(-4, 4, -5);
  scene.add(dl2);
  
  const grid = new THREE.GridHelper(6, 12, 0x546e7a, 0x37474f);
  grid.position.y = -T - 0.02;
  scene.add(grid);
  
  buildMDF();
  buildSlots();
  buildFilter();
  buildClips();
  
  showStep();
  setupControls();
  window.addEventListener('resize', onResize);
  animate();
}

function buildMDF() {
  const mat = new THREE.MeshPhongMaterial({ color: 0xCD853F, transparent: true, opacity: 0.9 });
  const g = new THREE.Group();
  
  const bLeft = HOLE_X1;
  const bRight = W - HOLE_X2;
  const bBottom = HOLE_Z1;
  const bTop = H - HOLE_Z2;
  
  // Bordas do MDF (furo central pequeno)
  g.add(box(W, T, bBottom, mat)).position.set(W/2, -T/2, bBottom/2);
  g.add(box(W, T, bTop, mat)).position.set(W/2, -T/2, H - bTop/2);
  g.add(box(bLeft, T, HOLE_H, mat)).position.set(bLeft/2, -T/2, (HOLE_Z1 + HOLE_Z2)/2);
  g.add(box(bRight, T, HOLE_H, mat)).position.set(W - bRight/2, -T/2, (HOLE_Z1 + HOLE_Z2)/2);
  
  scene.add(g);
  groups.mdf = g;
}

function buildSlots() {
  const mat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
  const g = new THREE.Group();
  
  SLOTS_H.forEach(([x, z]) => {
    g.add(box(0.10, T + 0.002, 0.02, mat)).position.set(x, -T/2, z);
  });
  SLOTS_V.forEach(([x, z]) => {
    g.add(box(0.02, T + 0.002, 0.10, mat)).position.set(x, -T/2, z);
  });
  
  scene.add(g);
  groups.slots = g;
}

function buildFilter() {
  const g = new THREE.Group();
  const centerX = W/2, centerZ = H/2;
  
  // Corpo do filtro HEPA (azul)
  const matBody = new THREE.MeshPhongMaterial({ color: 0x3498db, transparent: true, opacity: 0.6 });
  const innerW = FILT_W - BORDA_W*2;
  const innerH = FILT_H - BORDA_W*2;
  const innerT = FILT_T - BORDA_ESP;
  const body = box(innerW, innerT, innerH, matBody);
  body.position.set(centerX, innerT/2, centerZ);
  g.add(body);
  
  // Borda (branca)
  const matBorda = new THREE.MeshPhongMaterial({ color: 0xecf0f1, transparent: true, opacity: 0.9 });
  
  g.add(box(FILT_W, BORDA_ESP, BORDA_W, matBorda)).position.set(centerX, FILT_T - BORDA_ESP/2, centerZ - FILT_H/2 + BORDA_W/2);
  g.add(box(FILT_W, BORDA_ESP, BORDA_W, matBorda)).position.set(centerX, FILT_T - BORDA_ESP/2, centerZ + FILT_H/2 - BORDA_W/2);
  g.add(box(BORDA_W, BORDA_ESP, FILT_H - BORDA_W*2, matBorda)).position.set(centerX - FILT_W/2 + BORDA_W/2, FILT_T - BORDA_ESP/2, centerZ);
  g.add(box(BORDA_W, BORDA_ESP, FILT_H - BORDA_W*2, matBorda)).position.set(centerX + FILT_W/2 - BORDA_W/2, FILT_T - BORDA_ESP/2, centerZ);
  
  scene.add(g);
  groups.filter = g;
}

function buildClips() {
  const g = new THREE.Group();
  
  CLIPS.forEach(c => {
    const clip = makeClip();
    clip.position.set(c.x, 0, c.z);
    clip.rotation.y = c.rot;
    g.add(clip);
  });
  
  scene.add(g);
  groups.clips = g;
}

function makeClip() {
  const g = new THREE.Group();
  const mat = new THREE.MeshPhongMaterial({ color: 0xe67e22 });
  const dmat = new THREE.MeshPhongMaterial({ color: 0xc0392b });
  
  const wallH = T + BORDA_ESP + ABA_ESP + 0.01;
  
  // Parede
  g.add(box(CLIP_LARG, CLIP_PAREDE, wallH, mat)).position.set(0, -CLIP_PAREDE/2, BORDA_ESP/2 - T/2);
  
  // Base
  g.add(box(CLIP_LARG, BASE_PROF, CLIP_PAREDE, mat)).position.set(0, -BASE_PROF/2, -T - CLIP_PAREDE/2);
  
  // Aba (curta)
  g.add(box(CLIP_LARG, ABA_COMP, ABA_ESP, mat)).position.set(0, -ABA_COMP/2, BORDA_ESP + ABA_ESP/2);
  
  // 2 Dentes
  for (let d of [-1, 1]) {
    const tooth = box(0.08, 0.02, 0.012, dmat);
    tooth.position.set(d * DENTE_POS, -BASE_PROF + 0.01, -T + 0.006);
    g.add(tooth);
  }
  
  return g;
}

function box(w, h, d, mat) {
  return new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
}

function showStep() {
  const s = STEPS[step];
  document.getElementById('sT').textContent = s.title;
  document.getElementById('sD').textContent = s.desc;
  
  groups.mdf.visible = s.show.mdf;
  groups.slots.visible = s.show.slots;
  groups.filter.visible = s.show.filter;
  groups.clips.visible = s.show.clips;
  
  groups.filter.position.y = 0;
  groups.clips.children.forEach(c => c.position.y = 0);
  
  if (step === 1) animateFilter();
  if (step === 2) animateClips();
}

function animateFilter() {
  groups.filter.position.y = 0.35;
  function tick() {
    if (step !== 1) return;
    if (groups.filter.position.y > 0.002) {
      groups.filter.position.y -= 0.004;
      requestAnimationFrame(tick);
    } else {
      groups.filter.position.y = 0;
    }
  }
  tick();
}

function animateClips() {
  const clips = groups.clips.children;
  clips.forEach((c, i) => c.position.y = 0.30 + i * 0.02);
  let t = 0;
  function tick() {
    if (step !== 2) { clips.forEach(c => c.position.y = 0); return; }
    t += 0.02;
    let allDone = true;
    clips.forEach((c, i) => {
      const delay = i * 0.1;
      const progress = Math.min(1, Math.max(0, (t - delay) * 2));
      c.position.y = 0.30 * (1 - progress * progress * progress);
      if (progress < 1) allDone = false;
    });
    if (!allDone) requestAnimationFrame(tick);
    else clips.forEach(c => c.position.y = 0);
  }
  tick();
}

function next() { if (step < STEPS.length - 1) { step++; showStep(); } }
function prev() { if (step > 0) { step--; showStep(); } }

function setupControls() {
  const el = renderer.domElement;
  el.addEventListener('pointerdown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
    el.setPointerCapture(e.pointerId);
  });
  el.addEventListener('pointermove', e => {
    if (!isDragging) return;
    spherical.phi -= (e.clientX - prevMouse.x) * 0.005;
    spherical.theta = Math.max(0.1, Math.min(1.5, spherical.theta - (e.clientY - prevMouse.y) * 0.005));
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  el.addEventListener('pointerup', () => isDragging = false);
  el.addEventListener('wheel', e => {
    spherical.radius = Math.max(2, Math.min(10, spherical.radius + e.deltaY * 0.003));
  }, { passive: true });
  document.addEventListener('keydown', e => {
    if (e.key === 'ArrowRight') next();
    if (e.key === 'ArrowLeft') prev();
  });
}

function onResize() {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  
  const cx = W / 2, cz = H / 2;
  camera.position.set(
    cx + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta),
    spherical.radius * Math.sin(spherical.theta),
    cz + spherical.radius * Math.cos(spherical.phi) * Math.cos(spherical.theta)
  );
  camera.lookAt(cx, 0.05, cz);
  
  renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
